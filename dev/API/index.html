<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · WaveguideQED.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaveguideQED.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">WaveguideQED.jl</a></li><li><a class="tocitem" href="../theoreticalbackground/">Theoretical Background</a></li><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../detection/">Detection and Projections</a></li><li><a class="tocitem" href="../multiplewaveguides/">Multiple waveguides</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_lodahl/">Scattering on two level system</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Autogenerated-API-list"><span>Autogenerated API list</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/main/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><h2 id="Autogenerated-API-list"><a class="docs-heading-anchor" href="#Autogenerated-API-list">Autogenerated API list</a><a id="Autogenerated-API-list-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideAbsorption" href="#WaveguideQED.CavityWaveguideAbsorption"><code>WaveguideQED.CavityWaveguideAbsorption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CavityWaveguideAbsorption{B1,B2} &lt;: CavityWaveguideOperator{B1,B2}</code></pre><p>Structure for fast simultaneous Cavity creation and Waveguide annihilation operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideEmission" href="#WaveguideQED.CavityWaveguideEmission"><code>WaveguideQED.CavityWaveguideEmission</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CavityWaveguideEmission{B1,B2} &lt;: CavityWaveguideOperator{B1,B2}</code></pre><p>Structure for fast simultaneous cavity annihilation and waveguide creation operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideOperator" href="#WaveguideQED.CavityWaveguideOperator"><code>WaveguideQED.CavityWaveguideOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type used for operators on acting on a combined <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and cavity basis (<code>FockBasis</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.Detector" href="#WaveguideQED.Detector"><code>WaveguideQED.Detector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Detector(wa,wb)</code></pre><p>Detector operation defined by giving waveguide annihilation operator <code>wa</code> and <code>wb</code> from two subsystems. <code>wa</code> acts on the first subsystem of a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and <code>wb</code> on the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazySumKet" href="#WaveguideQED.LazySumKet"><code>WaveguideQED.LazySumKet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazySumKet(kets...)</code></pre><p>Lazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazyTensorBra" href="#WaveguideQED.LazyTensorBra"><code>WaveguideQED.LazyTensorBra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyTensorBra(bras)</code></pre><p>Lazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazyTensorKet" href="#WaveguideQED.LazyTensorKet"><code>WaveguideQED.LazyTensorKet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyTensorKet(kets)</code></pre><p>Lazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))" href="#WaveguideQED.OnePhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView(ψ::T) where {T&lt;:SingleWaveguideKet}
OnePhotonView(ψ::T,index::I) where {T&lt;:SingleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}
OnePhotonView(ψ::T,WI::Int)  where {T&lt;:MultipleWaveguideKet}
OnePhotonView(ψ::T,index::I,WI::Int) where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>Return a view of the onephoton wavefunction <span>$ξ(t)$</span> given a state containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a>. If the <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> contains more than one waveguide, a waveguide index <span>$WI$</span> is required to indicate which waveguide is viewed (1,2,3,... etc.)   If the state contains more basises (e.g. a cavity) <span>$index$</span> used to indicate which state should be viewed. Index should follow same form outlined in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a> and if not given the groundstate is assummed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L77-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonTimestepView" href="#WaveguideQED.TwoPhotonTimestepView"><code>WaveguideQED.TwoPhotonTimestepView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonTimestepView{T}</code></pre><p>Structure for viewing slice along same times in twophoton state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView" href="#WaveguideQED.TwoPhotonView"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwophotonView{T} &lt;: AbstractMatrix{T}</code></pre><p>Structure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))" href="#WaveguideQED.TwoPhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T) where {T &lt;: SingleWaveguideKet}
TwoPhotonView(ψ::T,index::I) where {T &lt;: SingleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}
TwoPhotonView(ψ::T,WI::Int) where {T &lt;: MultipleWaveguideKet}
TwoPhotonView(ψ::T,WI1::Int,WI2::Int) where {T &lt;: MultipleWaveguideKet}
TwoPhotonView(ψ::T,WI::I) where {T &lt;: MultipleWaveguideKet,I&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}}
TwoPhotonView(ψ::T,index::I,WI::Int)  where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>Return a view of the twophoton wavefunction <span>$ξ(t1,t2)$</span> given a state containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a>. If the <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> contains more than one waveguide, a waveguide index <span>$WI$</span> is required to indicate which waveguide is viewed. <code>WI</code> follows the same syntax  outlined in <a href="#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T"><code>twophoton</code></a> for more information on how to view the state. If the state contains more basises (e.g. a cavity) <span>$index$</span> used to indicate which state should be viewed. Index should follow same form outlined in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a> and if not given the groundstate is assummed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoWaveguideTimestepView" href="#WaveguideQED.TwoWaveguideTimestepView"><code>WaveguideQED.TwoWaveguideTimestepView</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TwoWaveguideTimestepView{T} &lt;:AbstractVector{T}</p><p>Structure for viewing slice along same times in one photon Left Right state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoWaveguideView" href="#WaveguideQED.TwoWaveguideView"><code>WaveguideQED.TwoWaveguideView</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TwoWaveguideView{T} &lt;: AbstractMatrix{T}</p><p>Structure for viewing state with one photon in Left and Right waveguide. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/view.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideBasis" href="#WaveguideQED.WaveguideBasis"><code>WaveguideQED.WaveguideBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideBasis(Np,Nw, times)
aveguideBasis(Np, times)</code></pre><p>Basis for time binned Waveguide where <code>Np</code> is the number of photons in the waveguide and <code>Nw</code> the number of waveguides (default is 1). . Currently number of photons is restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideCreate" href="#WaveguideQED.WaveguideCreate"><code>WaveguideQED.WaveguideCreate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideCreate{B1,B2,N,idx} &lt;: WaveguideOperator{B1,B2}</code></pre><p>Operator structure for dispatching creation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideDestroy" href="#WaveguideQED.WaveguideDestroy"><code>WaveguideQED.WaveguideDestroy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideDestroy{B1,B2,Np,idx} &lt;: WaveguideOperator{B1,B2}</code></pre><p>Operator structure for dispatching annihilation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideOperator" href="#WaveguideQED.WaveguideOperator"><code>WaveguideQED.WaveguideOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract class for WaveguideOperators. Used to dispatch special mul! function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}" href="#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}"><code>QuantumInterface.dagger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dagger(op::WaveguideCreate)
dagger(op::WaveguideCreate)</code></pre><p>Dagger opration on Waveguide operator. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}" href="#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}"><code>QuantumInterface.tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)
tensor(a::CavityWaveguideAbsorption,b::AbstractOperator)
tensor(a::AbstractOperator,b::CavityWaveguideEmission)
tensor(a::CavityWaveguideEmission,b::AbstractOperator)</code></pre><p>Methods for tensorproducts between QuantumOptics.jl operators and <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np" href="#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create(basis::WaveguideBasis{Np,1}) where {Np}
create(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Creation operator <span>$w^\dagger$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k)^\dagger | \emptyset \rangle = | 1_k \emptyset \rangle_i$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li>i determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p>WaveguideCreate{B,B,Np,i} &lt;: WaveguideOperator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np" href="#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">destroy(basis::WaveguideBasis{Np,1}) where {Np}
destroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Annihilation operator <span>$w$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k) | 1_j \emptyset \rangle_i = \delta_{k,j} | \emptyset \rangle$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li>i determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p>WaveguideDesroy{B,B,Np,i} &lt;: WaveguideOperator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}" href="#QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}"><code>QuantumOpticsBase.identityoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::CavityWaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}" href="#QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}"><code>QuantumOpticsBase.identityoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::WaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}" href="#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}"><code>WaveguideQED.absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorption(b1::WaveguideBasis{T},b2::FockBasis) where T
absorption(b1::FockBasis,b2::WaveguideBasis{T}) where T</code></pre><p>Create <a href="#WaveguideQED.CavityWaveguideAbsorption"><code>CavityWaveguideAbsorption</code></a> that applies <code>create(b::FockBasis)</code> on <code>FockBasis</code> and destroy(b::WaveguideBasis{T}) on <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{T}</code></a>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B" href="#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B"><code>WaveguideQED.detect_double_click</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_double_click(ψ,detector1,detector2,projection)
detect_double_click(ψ,detector1,detector2)</code></pre><p>Calculate probability of observing <code>projection</code> after beamsplitter operation and two subsequent detection events defined in <code>detector1</code> and <code>detector2</code> on the state <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ</code> can be either <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and is the state on which the beamsplitter and detection is applied</li><li><code>detector1</code> defines the first beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>detector2</code> defines the second beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>projection</code> if given is a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>projection</code> is given: Returns probability of having <code>detector1</code> and <code>detector2</code> click and being in state defined by <code>projection</code></li><li>If <code>projection</code> is not given: Returns the total probability of having <code>detector1</code> and <code>detector2</code> click by applying all possibile projections with zerophotons in the waveguide using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p>See <a href="https://mabuni1998.github.io/WaveguideQED/dev/detection_example/">Beamsplitter</a> for an example on how to use. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L284-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}" href="#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}"><code>WaveguideQED.detect_single_click</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_single_click(ψ,detector::Detector,projection)
detect_single_click(ψ,detector::Detector)</code></pre><p>Calculate probability of observing <code>projection</code> after beamsplitter operation and subsequent detection event defined in <code>detector</code> on the state <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ</code> can be either <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and is the state on which the beamsplitter and detection is applied</li><li><code>detector</code> defines the beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>projection</code> if given is a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>projection</code> is given returns probability of having detector click and being in state defined by <code>projection</code></li><li>If <code>projection</code> is not given returns the total probability of having a the detector click (only a single click, for double clicks use <a href="#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B"><code>detect_double_click</code></a>) by applying all possibile projections with zerophotons in the waveguide using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p>See <a href="https://mabuni1998.github.io/WaveguideQED/dev/detection_example/">Beamsplitter</a> for an example on how to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L149-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}" href="#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}"><code>WaveguideQED.emission</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emission(b1::WaveguideBasis{T},b2::FockBasis) where T
emission(b1::FockBasis,b2::WaveguideBasis{T}) where T</code></pre><p>Create <a href="#WaveguideQED.CavityWaveguideEmission"><code>CavityWaveguideEmission</code></a> that applies <code>destroy(b::FockBasis)</code> on <code>FockBasis</code> and create(b::WaveguideBasis{T}) on <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{T}</code></a>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}" href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>WaveguideQED.get_all_projectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_all_projectors(b)</code></pre><p>Returns all combinations of possible states with zerophotons in the waveguide. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/detection.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_nsteps-Tuple{WaveguideBasis}" href="#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}"><code>WaveguideQED.get_nsteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nsteps(basis::WaveguideBasis)
get_nsteps(basis::Basis)
get_nsteps(basis::CompositeBasis)</code></pre><p>Return nsteps of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> given either a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> or a <code>CompositeBasis</code> containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L279-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}" href="#WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}"><code>WaveguideQED.get_number_of_waveguides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_number_of_waveguides(basis::WaveguideBasis)
get_number_of_waveguides(basis::Basis)
get_number_of_waveguides(basis::CompositeBasis)</code></pre><p>Return number of waveguides Nw of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a> given either a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a> or a <code>CompositeBasis</code> containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L300-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}" href="#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}"><code>WaveguideQED.get_waveguide_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_basis(basis::CompositeBasis)</code></pre><p>Returns <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> from <code>CompositeBasis.bases</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L321-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}" href="#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}"><code>WaveguideQED.get_waveguide_location</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_location(basis::WaveguideBasis)
get_waveguide_location(basis::CompositeBasis)</code></pre><p>Return index of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> location in Hilbert space of basis b. <code>Btotal = waveguidebasis ⊗ otherbasis</code> where waveguidebasis is a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and <code>otherbasis</code> some other basis then <code>get_waveguide_location(Btotal)</code> returns 1.  While <code>Btotal = otherbasis ⊗ waveguidebasis</code> with <code>get_waveguide_location(Btotal)</code> returns 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L263-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}" href="#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}"><code>WaveguideQED.get_waveguide_operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_operators(basis::LazySum)
get_waveguide_operators(basis::LazyProduct)
get_waveguide_operators(basis::LazyTensor)
get_waveguide_operators(basis::Tuple)
get_waveguide_operators(basis::Array)
get_waveguide_operators(basis::WaveguideOperator)</code></pre><p>Returns all <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> in LazyOperator or from a list of operators. If no <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> is found, and empty array is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L389-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguidetimeindex-Tuple{Any}" href="#WaveguideQED.get_waveguidetimeindex-Tuple{Any}"><code>WaveguideQED.get_waveguidetimeindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguidetimeindex(op)</code></pre><p>Return timeindex of operator or list of operators containing <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> and assert that all timeindeces are the same. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L432-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T" href="#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onephoton(b::WaveguideBasis{T,1},ξ::Function,times,args...,norm=True) where {T}
onephoton(b::WaveguideBasis{T,1},ξvec;norm=true) where {T}
onephoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,times,args...; norm=true) where {T,Nw}
onephoton(b::WaveguideBasis{T,Nw},i,ξvec;norm=true) where {T,Nw}</code></pre><p>Create a onephoton wavepacket in waveguide of the form <span>$W^\dagger(\xi) |0 \rangle = \int_{t_0}^{t_{end}} dt  \xi(t) w_{\mathrm{i}}^\dagger(t) |\emptyset \rangle$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code>: the basis of the waveguides, where T is the number of photons in the waveguides and Nw is the number of waveguides.</li><li><code>i::Int</code> (optional): the index of the waveguide where the photon is created. If not provided, i=1 is assumed.</li><li><code>ξ::Function</code> or <code>ξ::AbstractArray</code>: the wavefunction of the state. Can be a function with structure ξ.(times,args...) or an <code>AbstractArray</code> of length <code>b.nsteps</code>.</li><li><code>times</code>: A vector or range of times where the wavefunction is evaluated, used only if ξ is a function.</li><li><code>args...</code>: additional arguments to be passed to ξ if it is a function.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul><p><strong>Returns</strong></p><ul><li>[<code>Ket(b)</code>]: a ket with the wavefunction defined above.</li></ul><p>If <code>b</code> only contains one waveguide, the output wavefunction will contain on excitation in the Waveguide (i=1). If <code>b</code> contains multiple waveguides and only one index is given (i or j), then i=j is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L54-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}" href="#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}"><code>WaveguideQED.plot_twophoton!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_twophoton!(ax,twophotonstate::TwophotonView,times)
plot_twophoton!(ax,twophotonstate::TwoWaveguideView,times)
plot_twophoton!(ax,state::Ket,times)
plot_twophoton!(ax,twophotonstate,times)</code></pre><p>Plots the twophoton state in the given ax. </p><p><strong>Arguments</strong></p><ul><li>ax of type PyObject &lt;AxesSubplot: &gt; from <code>PyPlot</code></li><li>State to be plotted twophotonstate or state. If state is a <code>Ket</code> <a href="#WaveguideQED.TwoPhotonView"><code>TwoPhotonView</code></a> is called to extract twophotonstate. Otherwise twophotonstate should be AbstractArray of dimensions (length(times),length(times)).</li></ul><p>#Return ax.contour object with the plotted state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/plotting.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator" href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>WaveguideQED.set_waveguidetimeindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_waveguidetimeindex!(op,index)</code></pre><p>Set timeindex of all <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> in operator or list of operators to index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L450-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T" href="#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,1},ξ::Function,times,args...,norm=True) where {T}
twophoton(b::WaveguideBasis{T,1},ξvec::Matrix;norm=true) where {T}
twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,times,args...;norm=true) where {T,Nw}
twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Matrix;norm=true) where {T,Nw}
twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Function,times,args...;norm=true) where {T,Nw}
twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Matrix;norm=true) where {T,Nw}
twophoton(b::WaveguideBasis{T,Nw},WI::I,ξ::Matrix;norm=true) where {T,Nw,I&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}}
twophoton(b::WaveguideBasis{T,Nw},WI::I,ξ::Function,times,args...;norm=true)</code></pre><p>Create a twophoton wavepacket of the form <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code>: the basis of the waveguides, where T is the number of photons in the waveguides and Nw is the number of waveguides.</li><li><code>i::Int</code> (optional): the index of the waveguide where the first photon is created. If not provided, i=1 is assumed.</li><li><code>j::Int</code> (optional): the index of the waveguide where the second photon is created. If not provided, j=i is assumed.</li><li><code>ξ::Function</code> or <code>ξ::Matrix</code>: the wavefunction of the state. Can be a function with structure ξ(times[l],times[m],args...) or a matrix of dimension <code>(b.nsteps, b.nsteps)</code>.</li><li><code>times</code>: A vector or range of times where the wavefunction is evaluated, used only if ξ is a function.</li><li><code>args...</code>: additional arguments to be passed to ξ if it is a function.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul><p><strong>Returns</strong></p><ul><li>[<code>Ket(b)</code>]: a ket with the wavefunction defined above.</li></ul><p>If <code>b</code> only contains one waveguide, the output wavefunction will contain two excitations in the same waveguide (i=j=1). If <code>b</code> contains multiple waveguides and only one index is given (i or j), then i=j is assumed, and two excitations in the same waveguide are returned. <code>i</code> and <code>j</code> can also be given as a tuple or vector <code>WI= (i,j)</code> or <code>WI= [i,j]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L116-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}" href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>WaveguideQED.view_waveguide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_waveguide(ψ::ket)
view_waveguide(ψ::ket,index)</code></pre><p>View the Waveguide state given a state ψ containing a WaveguideBasis by returning <code>view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...)</code>. If no index is provided the ground state is returned. The index provided should be of the form <code>[:,i,j]</code> where <code>(:)</code> is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: </p><pre><code class="language- hljs">julia&gt; using WaveguideQED; #hide
julia&gt; using QuantumOptics; #hide
julia&gt; times=0:0.1:10;
julia&gt; bw = WaveguideBasis(2,times);
julia&gt; bc1 = FockBasis(2);
julia&gt; bc2 = FockBasis(2);
julia&gt; ψ_waveguide = onephoton(bw,x-&gt;1);
julia&gt; ψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1);
julia&gt; ψ_view = view_waveguide(ψ_total);
julia&gt; ψ_view_index = view_waveguide(ψ_total,[:,1,1]);
julia&gt; ψ_view==ψ_view_index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L233-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}" href="#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}"><code>WaveguideQED.waveguide_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">waveguide_evolution(tspan, psi0, H; fout)</code></pre><p>Integrate time-dependent Schroedinger equation to evolve states or compute propagators.</p><p><strong>Arguments</strong></p><ul><li><code>tspan</code>: Vector specifying the points of time for which output should be displayed.</li><li><code>psi0</code>: Initial state vector can only be a ket.</li><li><code>H</code>: Operator containing a <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> either through a LazySum or LazyTensor.</li><li><code>fout=nothing</code>: If given, this function <code>fout(t, psi)</code> is called every time step. Example: <code>fout(t,psi) = expect(A,psi)</code> will return the epectation value of A at everytimestep.  If <code>fout =1</code> the state psi is returned for all timesteps in a vector.  ATTENTION: The state <code>psi</code> is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.</li></ul><p><strong>Returns</strong></p><ul><li>if <code>fout=nothing</code> the output of the solver will be the state <code>ψ</code> at the last timestep. </li><li>if <code>fout</code> is given a tuple with the state <code>ψ</code> at the last timestep and the output of <code>fout</code> is given. If <code>fout</code> returns a tuple the tuple will be flattened.</li><li>if <code>fout = 1</code> <code>ψ</code> at all timesteps is returned.</li></ul><p>Example <code>fout(t,psi) = (expect(A,psi),expect(B,psi))</code> will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where <code>⟨A(t)⟩</code> is a vector with the expectation value of <code>A</code> as a function of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/solver.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.waveguide_montecarlo-NTuple{4, Any}" href="#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}"><code>WaveguideQED.waveguide_montecarlo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">waveguide_montecarlo(times,psi,H,J;fout=nothing)</code></pre><p>See documentation for <a href="#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}"><code>waveguide_evolution</code></a>. J should be a list of collapse operators. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/solver.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.zerophoton-Tuple{WaveguideBasis}" href="#WaveguideQED.zerophoton-Tuple{WaveguideBasis}"><code>WaveguideQED.zerophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zerophoton(bw::WaveguideBasis)</code></pre><p>Create a waveguide vacuum state |0⟩</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/basis.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)</code></pre><p>In-place multiplication of operators/state vectors. Updates <code>result</code> as <code>result = alpha*a*b + beta*result</code>. <code>a</code> is a LazyTensor that contains a <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L168-L172">source</a></section><section><div><pre><code class="nohighlight hljs">mul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1&lt;:Basis,B2&lt;:Basis}
mul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1&lt;:Basis,B2&lt;:Basis}</code></pre><p>Fast in-place multiplication of operators/state vectors. Updates <code>result</code> as <code>result = alpha*a*b + beta*result</code>. <code>a</code> is a <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L413-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create" href="#QuantumOpticsBase.create"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create(basis::WaveguideBasis{Np,1}) where {Np}
create(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Creation operator <span>$w^\dagger$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k)^\dagger | \emptyset \rangle = | 1_k \emptyset \rangle_i$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li>i determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p>WaveguideCreate{B,B,Np,i} &lt;: WaveguideOperator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy" href="#QuantumOpticsBase.destroy"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">destroy(basis::WaveguideBasis{Np,1}) where {Np}
destroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Annihilation operator <span>$w$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k) | 1_j \emptyset \rangle_i = \delta_{k,j} | \emptyset \rangle$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li>i determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p>WaveguideDesroy{B,B,Np,i} &lt;: WaveguideOperator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dagger" href="#QuantumInterface.dagger"><code>QuantumInterface.dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dagger(op::WaveguideCreate)
dagger(op::WaveguideCreate)</code></pre><p>Dagger opration on Waveguide operator. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor" href="#QuantumInterface.tensor"><code>QuantumInterface.tensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)
tensor(a::CavityWaveguideAbsorption,b::AbstractOperator)
tensor(a::AbstractOperator,b::CavityWaveguideEmission)
tensor(a::CavityWaveguideEmission,b::AbstractOperator)</code></pre><p>Methods for tensorproducts between QuantumOptics.jl operators and <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.identityoperator" href="#QuantumOpticsBase.identityoperator"><code>QuantumOpticsBase.identityoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::WaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/WaveguideOperator.jl#L151-L155">source</a></section><section><div><pre><code class="language-julia hljs">identityoperator(a::CavityWaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mabuni1998/WaveguideQED.jl/blob/80287055ebadfde0cef7a3caf3b3c5a036dd0e42/src/CavityWaveguideOperator.jl#L223-L227">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example_lodahl/">« Scattering on two level system</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 11 April 2023 16:55">Tuesday 11 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
