var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"#Interference on beamsplitter","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Define two waveguides each occupied by a single photon with a gaussian wavefunction ","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"''' times = 0:0.1:20 bw = WaveguideBasis(1,times) wa = destroy(bw) wb = destroy(bw)","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"ξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)exp(-2log(2)*(t-t0)^2/σ^2)) waveguidea = onephoton(bw,ξfun,1,10,times) waveguideb = onephoton(bw,ξfun,1,10,times) ψtotal = LazyTensorKet(waveguidea,waveguide_b) ''' Define the effect of 50/50 beamsplitter labeling the two detectors after the beamsplit \"plus\" and \"minus\"","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"''' detectorplus = Detector(wa/sqrt(2),wb/sqrt(2)) detectorminus = Detector(wa/sqrt(2),-wb/sqrt(2)) '''","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Calculate the probability of having two clicks in plus, in click in minus or one in both:","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"''' pplusplusclick = detectdoubleclick(ψtotal,detectorplus,detectorplus) pminusminusclick = detectdoubleclick(ψtotal,detectorminus,detectorminus) pplusminusclick = detectdoubleclick(ψtotal,detectorplus,detectorminus) pminusplusclick = detectdoubleclick(ψtotal,detectorminus,detectorplus)","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"println(\"Probability of having two clicks in detector plus: p_plus_plus_click\") println(\"Probability of having two clicks in detector minus: p_minus_minus_click\") println(\"Probability of having one click in detector plus and one in detector minus: p_plus_minus_click + p_minus_plus_click\") '''","category":"page"},{"location":"#CavityWaveguide.jl","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"","category":"section"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"CavityWaveguide.jl is a package for simulating ","category":"page"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"DocTestSetup = quote\n    using CavityWaveguide\nend","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CavityWaveguide]\nPrivate = false","category":"page"},{"location":"API/#CavityWaveguide.CavityWaveguideAbsorption","page":"API","title":"CavityWaveguide.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity creation and waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideEmission","page":"API","title":"CavityWaveguide.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideOperator","page":"API","title":"CavityWaveguide.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.Detector","page":"API","title":"CavityWaveguide.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator 'wa' and 'wb' from two subsystems. 'wa' acts on the first subsystem of a 'LazyTensorKet' or 'LazySumKet' and 'wb' on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazySumKet","page":"API","title":"CavityWaveguide.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazyTensorKet","page":"API","title":"CavityWaveguide.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.TwophotonTimestepView","page":"API","title":"CavityWaveguide.TwophotonTimestepView","text":"TwophotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.TwophotonView","page":"API","title":"CavityWaveguide.TwophotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory). Returned from view_twophoton. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideBasis","page":"API","title":"CavityWaveguide.WaveguideBasis","text":"WaveguideBasis(N, times)\n\nBasis for time binned Waveguide where N is the number of photons in the waveguide. Currently restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideCreate","page":"API","title":"CavityWaveguide.WaveguideCreate","text":"WaveguideCreate{N} <: WaveguideOperator\n\nOperator structure for dispatching creation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideDestroy","page":"API","title":"CavityWaveguide.WaveguideDestroy","text":"WaveguideDestroy{N} <: WaveguideOperator\n\nOperator structure for dispatching annihilation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideOperator","page":"API","title":"CavityWaveguide.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.absorption-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"CavityWaveguide.detect_double_click","text":"detect_double_click(ψ,detector1::Detector{B},detector2::Detector{B},projection) where {B}   \ndetect_double_click(ψ,detector1::Detector{B},detector2::Detector{B}) where B\n\nCalculate probability of observing 'projection' after beamsplitter operation and two subsequent detection events defined in 'detector1' and 'detector2' on the state 'ψ'.\n\n#Arguments\n\n'ψ' can be either 'LazyTensorKet' or 'LazySumKet' and is the state on which the beamsplitter and detection is applied\n'detector1' defines the first beamsplitter and subsequent detection operation. See 'Detector' for more details on how to define.\n'detector2' defines the second beamsplitter and subsequent detection operation. See 'Detector' for more details on how to define.\n'projection' if given is a 'LazyTensorKet' or 'LazySumKet' which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using 'getallprojectors'.\n\n#Returns\n\nIf 'projection' is given: Returns probability of having 'detector1' and 'detector2' click and being in state defined by 'projection' If 'projection' is not given: Returns the total probability of having 'detector1' and 'detector2' click by applying all possibile projections with zerophotons in the waveguide using 'getallprojectors'.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"CavityWaveguide.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing 'projection' after beamsplitter operation and subsequent detection event defined in 'detector' on the state 'ψ'.\n\n#Arguments\n\n'ψ' can be either 'LazyTensorKet' or 'LazySumKet' and is the state on which the beamsplitter and detection is applied\n'detector' defines the beamsplitter and subsequent detection operation. See 'Detector' for more details on how to define.\n'projection' if given is a 'LazyTensorKet' or 'LazySumKet' which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using 'getallprojectors'.\n\n#Returns\n\nIf 'projection' is given returns probability of having detector click and being in state defined by 'projection' If 'projection' is not given returns the total probability of having a the detector click (only a single click, for double clicks use 'detectdoubleclick') by applying all possibile projections with zerophotons in the waveguide using 'getallprojectors'.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.emission-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"CavityWaveguide.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = BW ⊗ BC where BW is a WaveguideBasis and BC some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = BC ⊗ BW with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"CavityWaveguide.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(basis::WaveguideBasis)\nget_waveguidetimeindex(basis::Basis)\nget_waveguidetimeindex(basis::CompositeBasis)\n\nReturn timeindex of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.onephoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.onephoton","text":"onephoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\nonephoton(b::WaveguideBasis,ξvec;norm=true)\n\nCreate a onephoton wavepacket of the form W^(ξ) 0 = int_t_0^t_end dt  ξ(t) w^(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ.(times,args...). ξvec is a vector of length: b.nsteps. If norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"CavityWaveguide.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.twophoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.twophoton","text":"twophoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\ntwophoton(b::WaveguideBasis,ξvec::Matrix;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  ξ(tt) w^(t)w^(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ(t1,t2,args...). ξvec is a matrix of dimension: (b.nsteps,b.nsteps), where ξvec[i,j] = ξ(times[i],times[j]), where times is defined in WaveguideBasis.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.view_onephoton-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.view_onephoton","text":"view_onephoton(ψ::Ket)\nview_onephoton(ψ::Ket,index)\n\nReturn a view of the onephoton mode ξ(t) given an input state containing a onephoton waveguide state: int_t_0^t_end dt  ξ(t) w^(t) 0 If no index is provided the ground state is returned. Index should follow same form outlined in view_waveguide.\n\nTO DO: PERHAPS CHANGE NAME?\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.view_twophoton-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.view_twophoton","text":"view_twophoton(ψ::Ket)\nview_twophoton(ψ::Ket,index)\n\nReturn a view of the twophoton mode ξ(t_1t_2) given an input state containing a twophoton waveguide state: int_t_0^t_end dt int_t_0^t_end dt  ξ(tt) w^(t)w^(t) 0 If no index is provided the ground state is returned. Index should follow same form outlined in view_waveguide.\n\nTO DO: PERHAPS CHANGE NAME?\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\ntimes=0:0.1:10\nbw = WaveguideBasis(2,times)\nbc1 = FockBasis(2)\nbc2 = FockBasis(2)\nψ_waveguide = onephoton(bw,x->1)\nψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1)\nψ_view = view_waveguide(ψ_total)\nψ_view_index = view_waveguide(ψ_total,[:,1,1])\nψ_view==ψ_view_index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"CavityWaveguide.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.   ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nOutput\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\n\nExample fout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"CavityWaveguide.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\nmul!(result::Bra{B1}, a::Bra{B2}, b::LazyTensor{B1,B2,F,I,T}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideOperator, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Bra{B1}, a::Bra{B2}, b::CavityWaveguideOperator, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator. Routine only works if [WaveguideBasis] is the first or last basis in Hilbertspace. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(basis::WaveguideBasis{1})\ndagger(basis::WaveguideBasis{2})\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(op1::AbstractOperator,op2::CavityWaveguideAbsorption)\ntensor(op1::CavityWaveguideAbsorption,op2::AbstractOperator)\ntensor(op1::AbstractOperator,op2::CavityWaveguideEmission)\ntensor(op1::CavityWaveguideEmission,op2::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"function"}]
}
