var documenterSearchIndex = {"docs":
[{"location":"tutorial/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In this section, we show simple examples that illustrate how to use WaveguideQED.jl in combination with QuantumOptics.jl","category":"page"},{"location":"tutorial/#combining","page":"Tutorials","title":"Combining with QuantumOptics.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Basises, states, and operators defined in WaveguideQED.jl can be effortlessly combined with operators from QuantumOptics.jl. As an example, we are going to consider a waveguide with a single photon pulse impinging on an empty onesided cavity. A sketch of the system can be seen here:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We start by defining the basis of the cavity and waveguide:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using WaveguideQED\nusing QuantumOptics\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nbc = FockBasis(1)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Next, we want to create the Hamiltonian for the system. The interaction between the waveguide and cavity is at timestep k given by[1] H_k = i hbar sqrtgamma  Delta t( a^dagger w_k - a w_k^dagger), where a (a^dagger) is the cavity annihilation (creation) operator, w_k(w_k^dagger) is the waveguide annihilation (creation) operator, gamma is the leakage rate of the cavity, and Delta t = mathrmtimes2-mathrmtimes1 is the width of the time-bin. WaveguideQED.jl follows the same syntax as QuantumOptics.jl, and operators are defined from a basis. Operators of different Hilbert spaces are then combined using ⊗ (\\otimes) or tensor:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"a = destroy(bc)\nad = create(bc)\nw = destroy(bw)\nwd = create(bw)\ndt = times[2] - times[1]\nγ = 1\nH = im*sqrt(γ/dt)*( ad ⊗ w - a ⊗ wd  )\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With this, we can now simulate the scattering of a single photon with a Gaussian wavefunction scattered on a cavity. We define the initial state as waveguide state as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ_waveguide = onephoton(bw,ξ,σ,t0)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Assuming the cavity is empty, the combined initial state is then:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_in = fockstate(bc,0) ⊗ ψ_waveguide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With the initial state, we can then call the solver the get the wavefunction after the interaction with the cavity.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out = waveguide_evolution(times,ψ_in,H)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Plotting the wavefunction and its norm square gives:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using PyPlot\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nviewed_state = OnePhotonView(ψ_out)\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,real.(viewed_state),\"r-\",label=\"Real part\")\nax[1].set_xlabel(\"Time [a.u]\")\nax[1].set_ylabel(L\"$\\xi(t)$\")\n\nax[2].plot(times,abs.(viewed_state).^2,\"r-\")\nax[2].set_xlabel(\"Time [a.u]\")\nax[2].set_ylabel(L\"$|\\xi(t)|^2$\")\nplt.tight_layout() #hide\nplt.savefig(\"scat_onephoton.svg\") #hide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We see that the wavefunction has changed after the interaction with the cavity. More specifically, we see how the pulse gets absorbed into the cavity leading to a phase change in the wavefunction. This phase change also leads to destructive interference between the photon being emitted from the cavity and the reflection of the incoming photon. This leads to a dip in the photon wavefunction after the interaction.","category":"page"},{"location":"tutorial/#Expectation-values","page":"Tutorials","title":"Expectation values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In the previous example, only the state at the final timestep was shown. This shows the output wavefunction, but one might also be interested in intermediate states or expectation values. Expectation values can be outputted from the solver by using the fout keyword. As an example, we can get the number of photons in the cavity as a function of time by:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na(time,psi)\n    expect(n,psi)\nend\nψ_out,na = waveguide_evolution(times,ψ_in,H,fout=exp_na)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we also want to know the number of photons in the waveguide state as a function of time, another operator to out expectation function as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nn_w = identityoperator(bc) ⊗ (create(bw)*destroy(bw))\nfunction exp_na_and_nw(time,psi)\n    (expect(n,psi),expect(n_w,psi))\nend\nψ_out,na,nw = waveguide_evolution(times,ψ_in,H,fout=exp_na_and_nw)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Where expect(n_w,psi) calculates the expectation value of all times of the pulse at each timestep: mathrmexpect(n_wpsi) = brapsi sum_k  I otimes w_k^dagger w_k  ketpsi","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"This can be plotted as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,na,\"b-\",label=\"na\")\nax.plot(times,nw,\"r-\",label=\"nw\")\nax.plot(times,nw+na,\"g-\",label=\"na+nw\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(\"Population\")\nax.legend()\nplt.tight_layout()\nplt.savefig(\"photon_number.svg\") #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Here we see how the photon wavepacket is partially absorbed into the cavity and then reemitted again.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we plot the wavefunction as a function of time (and do some displacing), we can even animate the process:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"example_lodahl/#Scattering-on-a-two-level-system","page":"Scattering on two level system","title":"Scattering on a two-level system","text":"","category":"section"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"In the following, we show that with our framework, we can reproduce the theoretical results obtained in Le Jeannic, et al. Nat. Phys. 18, 1191–1195 (2022)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"In many of the examples considered so far, we only consider a single waveguide that serves as both input and output, thus only allowing for only one-sided cavities or quantum systems at the end of a waveguide. A more realistic scenario is having a waveguide with a quantum system in the middle. Here an incoming waveguide carrying an excitation could scatter on the quantum system, and one would have excitations going away from the quantum system in both the first and latter part of the waveguide, as illustrated here:[1]","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"[1]: Hanna Le Jeannic, Alexey Tiranov, Jacques Carolan, Tomás Ramos, Ying Wang, Martin Hayhurst Appel, Sven Scholz, Andreas D. Wieck, Arne Ludwig, Nir Rotenberg, Leonardo Midolo, Juan José García-Ripoll, Anders S. Sørensen, Peter Lodahl (2022)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: `alt text`)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"A way to model this scenario is to have two waveguides: a waveguide to the left and the right, describing the first half of the waveguide and the latter half. For this, we use WaveguideBasis but with an extra argument specifying that we need two waveguides (see Multiple Waveguides for an introduction). We initialize WaveguideBasis with two waveguides and a basis for the atom (note that a fockbasis with only one excitation allowed is the same as a two-level-system):","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nbw = WaveguideBasis(2,2,times)\nbe = FockBasis(1)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"We then define the operators for the interaction between atom and waveguide as (notice the second argument in create(bw,1) that defines which waveguide we are addressing):","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"wdLa = create(bw,1) ⊗ destroy(be)\nadwL = destroy(bw,1) ⊗ create(be)\nwdRa = create(bw,2) ⊗ destroy(be)\nadwR = destroy(bw,2) ⊗ create(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"where mathrmwdLa = w_L ^dagger a, mathrmwdRa = w_R ^dagger a, mathrmadwL = w_L  a^dagger, and mathrmadwR = w_R  a^dagger. In this example, we, however, also need an interaction between the waveguides. Therefore we define the creation and annihilation operators:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"wdL = create(bw,1) ⊗ identityoperator(be)\nwL = destroy(bw,1) ⊗ identityoperator(be)\nwdR = create(bw,2) ⊗ identityoperator(be)\nwR = destroy(bw,2) ⊗ identityoperator(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"The interaction should carry over the momentum of the left waveguide into the waveguide on the right, and the interaction should therefore model a SWAP gate. This corresponds to V = pi 2 and thus we have the interaction Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"V = pi/2\nκ1 = 1\nκ2 = 1\nH = im*sqrt(κ1/dt)*(adwL-wdLa) + im*sqrt(κ2/dt)*(wdRa-adwR) + V/dt *(wdR*wL + wdL* wR)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"We can now study how single or two-photon states scatter on the atom. We define the initial one-photon or two-photon Gaussian state and solve it using the defined Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ξ₁(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξ₂(t1,t2,σ1,σ2,t0) = ξ₁(t1,σ1,t0) * ξ₁(t2,σ2,t0) \nw = 1\nt0 = 5\nψ1 = onephoton(bw,1,ξ₁,w,t0) ⊗ fockstate(be,0)\nψ2 = twophoton(bw,1,ξ₂,w,w,t0) ⊗ fockstate(be,0)\nψScat1 = waveguide_evolution(times,ψ1,H)\nψScat2 = waveguide_evolution(times,ψ2,H)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"Viewing the scattered states is then done using TwoPhotonView and the index for the corresponding waveguide. Giving two indices returns instead the combined single photon state in both waveguides sum_jk ket1_j_1 ket1_k_2:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ψ2LeftScat = TwoPhotonView(ψScat2,1,[:,1])\nψ2RightScat = TwoPhotonView(ψScat2,2,[:,1])\nψ2LeftRightScat = TwoPhotonView(ψScat2,2,1,[:,1])\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"For the single-photon states, we have to calculate the two-time scattered distribution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ψ1LeftScat = zeros(ComplexF64,(length(times),length(times)))\nψ1RightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1LeftRightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1Right = OnePhotonView(ψScat1,2,[:,1])\nψ1Left = OnePhotonView(ψScat1,1,[:,1])\n\nfor i in eachindex(times)\n    for j in eachindex(times)\n        ψ1LeftScat[i,j] = ψ1Left[i]*ψ1Left[j]\n        ψ1RightScat[i,j] = ψ1Right[i]*ψ1Right[j]\n        ψ1LeftRightScat[i,j] = ψ1Left[i]*ψ1Right[j]\n    end\nend\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"Finally, we can plot the scattered wavefunctions, and we note that this matches Fig. 3 in Ref.[1]:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"using PyPlot; #hide\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nfig,axs = subplots(3,2,figsize=(6,9))\nplot_list = [ψ2RightScat,ψ2LeftScat,ψ2LeftRightScat,ψ1RightScat,ψ1LeftScat,ψ1LeftRightScat]\nfor (i,ax) in enumerate(axs)\n    plot_twophoton!(ax,plot_list[i],times)\nend\naxs[1].set_ylabel(\"\\$C^{RR}\\$ \\n t2 [a.u]\")\naxs[2].set_ylabel(\"\\$C^{LL}\\$ \\n t2 [a.u]\")\naxs[3].set_ylabel(\"\\$C^{LR}\\$ \\n t2 [a.u]\")\naxs[3].set_xlabel(\"t1 [a.u]\")\naxs[6].set_xlabel(\"t1 [a.u]\")\nplt.tight_layout()\nplt.savefig(\"lodahl_fig3.svg\") #hide\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: lodahl)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"If we consider the single photon state, we can also visualize the temporal evolution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: alt text)","category":"page"},{"location":"references/#Suggested-readings","page":"References and suggested readings","title":"Suggested readings","text":"","category":"section"},{"location":"references/#Theory-and-background","page":"References and suggested readings","title":"Theory and background","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The theory of time-bin continuous fockstates is introduced in Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020) where it is used to derive the equations of motion for Waveguide QED systems. The numerical method in this library is heavily based on this approach, where instead of deriving the equations, the systems are solved by applying the operators themselves. The time-bin method is also used in Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020) and Stefan Krastanov, Kurt Jacobs, Gerald Gilbert, Dirk R. Englund, Mikkel Heuck (2022).","category":"page"},{"location":"references/#Similar-approaches","page":"References and suggested readings","title":"Similar approaches","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The following is a list of approaches that are trying to solve problems that can also be treated with this library.","category":"page"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"Sofia Arranz Regidor, Gavin Crowder, Howard Carmichael, Stephen Hughes (2021) considers feedback in waveguide systems and uses a space-discretized waveguide picture with Monte Carlo trajectories\nKevin A. Fischer, Rahul Trivedi, Daniil Lukin (2018) relates many approaches to solving WaveguideQED problems with each other and also introduces a framework that aims to deal with similar problems through master equations, photon counting and tracing out the waveguide.\nThe SLH formalism introduced in Alexander Holm Kiilerich, Klaus Mølmer (2019) and Alexander Holm Kiilerich, Klaus Mølmer (2019) uses cascaded cavities to simulate quantum pulses. Further work also includes: Fan Yang, Mads M. Lund, Thomas Pohl, Peter Lodahl, Klaus Mølmer (2022) Victor Rueskov Christiansen, Alexander Holm Kiilerich, Klaus Mølmer (2023)","category":"page"},{"location":"references/#Papers-where-we-reproduce-results-from","page":"References and suggested readings","title":"Papers where we reproduce results from","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The theoretical results in Hanna Le Jeannic, Alexey Tiranov, Jacques Carolan, Tomás Ramos, Ying Wang, Martin Hayhurst Appel, Sven Scholz, Andreas D. Wieck, Arne Ludwig, Nir Rotenberg, Leonardo Midolo, Juan José García-Ripoll, Anders S. Sørensen, Peter Lodahl (2022) are reproduced in Scattering on a two-level system","category":"page"},{"location":"references/#References","page":"References and suggested readings","title":"References","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"","category":"page"},{"location":"theoreticalbackground/#Theoretical-Background","page":"Theoretical Background","title":"Theoretical Background","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In this section, we go over the necessary theory to work with continuous fockstates in the WaveguideQED.jl","category":"page"},{"location":"theoreticalbackground/#Continuous-Fock-States","page":"Theoretical Background","title":"Continuous Fock States","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: leftw(t)w(t)right  = delta(t-t). The probability of observing a photon at time t is given by: brapsi w^dagger(t) w(t) ketpsi = xi^(1)(t)^2. The interpretation of the wavefunction xi^(1)(t). The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The heart of the photon time-binning is discretizing the continuous fock state into time-bins of width Delta t. The interaction with the emitter/cavity is then assumed to span only one time-bin at a time, corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. We denote the action of the discretized creation operator as: w_k^dagger ketemptyset = ket1_k meaning a single photon in time-bin k. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In WaveguideQED.jl, the time-bins above are represented as elements in arrays corresponding to each time-bin:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Let`s say you want to represent a single photon continuous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done by creating a waveguide basis defined on such a time interval:a","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using WaveguideQED\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2), and times the is the time interval over which the continuous fockstate is defined. To define the continuous fockstate, we need to define a wavefunction xi. In the following, we define a Gaussian wavefunction located around t=5 with a width of sigma = 1:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ = onephoton(bw,ξ,σ,t0)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This state can be visualized by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using PyPlot\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(viewed_state),\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout() #hide\nplt.savefig(\"one_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-binned creation and annihilation operators are easily created from the basis:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w = destroy(bw)\nwd = create(bw)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-bin that the operator acts on is set by either:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w.timeindex = 10\nwd.timeindex = 10\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"or:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(w,10)\nset_waveguidetimeindex!(wd,10)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The effect of the creation operator is to create a photon in timebin k and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This is also seen if we plot the creation operator acting on the vacuum:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ψ = wd*zerophoton(bw)\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(viewed_state),\"r-\");\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()\nplt.savefig(\"created_onephoton_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We see a spike around t = times[10] = 0.9, where we now created an excitation. In itself, the waveguide basis, states, and operators are not particularly interesting, but when combined with other quantum mechanical systems such as cavities and emitters, the framework can produce powerful results. See Combining with QuantumOptics for an introduction on how to combine with quantum systems defined in 'QuantumOptics.jl'.","category":"page"},{"location":"theoreticalbackground/#Continuous-two-photon-fock-states","page":"Theoretical Background","title":"Continuous two-photon fock states","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"So far, we have considered only one excitation in the waveguide. We can extend the definition of a one-photon continuous fock state to a two-photon state as[2]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we here defined the two photon wavefunction xi^(2)(tt) = xi(t) xileft(t^primeright). The state is now defined over two times, which describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state xi^(2)(tt) = xi(t) xileft(t^primeright), and both probabilities are described by the (same) single photon wavefunction xi(t), but one could have entangled states across time. This means a non-seperable wavefunction xi^(2)(tt) neq xi_1(t)xi_2(t). For now, we will consider a symmetric and separable state.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-binning is in a similar fashion defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac2sqrt2 sum_i=1^N sum_ki^N xileft(t_iright) xileft(t_kright)left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =sqrt2 sum_i=1^N sum_k  i^N xileft(t_iright) xileft(t_kright) mid 1_t_i 1_t_krangle + sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent to having one photon at time-bin k and then one photon at time-bin j or one photon at time-bin j and then one photon at time-bin k). This is how the two-photon state is saved in the underlying arrays and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Creating then is:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We can define a two-photon basis and corresponding operator by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"bw = WaveguideBasis(2,times)\nw = destroy(bw)\nwd = create(bw)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The creation operator can then be visualized by acting on onephoton filled with ones. This is seen in the following. Note that the state is visualized as a contour plot mirrored around the diagonal.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(wd,50)\npsi_plot = wd*onephoton(bw,x->1)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,psi_plot,times)\nplt.savefig(\"twophoton_created.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"If we want to create a two-photon Gaussian state, we instead do:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ = twophoton(bw,ξ2,σ,t0)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we defined the two-photon equivalent of our single-photon Gaussian state. When we visualize it, we now need two times, and we make a contour plot. This is easily done by viewing the two-photon state and using plot_twophoton!: ","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"viewed_state = TwoPhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,viewed_state,times)\nax.set_ylabel(\"time [1/γ]\")\nax.set_xlabel(\"time [1/γ]\") \nplt.tight_layout()\nplt.savefig(\"two_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[2]: Ben Q. Baragiola, Robert L. Cook, Agata M. Branczyk, Joshua Combes (2012)","category":"page"},{"location":"multiplewaveguides/#Multiple-waveguides","page":"Multiple waveguides","title":"Multiple waveguides","text":"","category":"section"},{"location":"multiplewaveguides/#twowaveguide","page":"Multiple waveguides","title":"Two Waveguides","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"In the previous examples, we have only considered cases with a single waveguide. In this tutorial, we show how to model a beamsplitter and an optical switch using two waveguides. A beamsplitter or a swap gate can be modeled using the Hamiltonian H_I = V(w_1^dagger w_2 + w_2^dagger w_1) where V is some interaction strength that determines which interaction is modeled (we will discuss this in detail later). w_1 and w_2 are the annihilation operators of the two waveguides. A sketch of the system can be seen here:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can describe the state of two waveguides with a total of N excitations by adding an argument specifying the number of waveguides as:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nNPhotons = 2\nNWaveguides = 2\nbw = WaveguideBasis(NPhotons,NWaveguides,times)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"When creating operators, we now have to specify which waveguide they are acting on (in this case, number one or two). This is done by an extra argument to create and destroy:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"wd1 = create(bw,1)\nw1 = destroy(bw,1)\nwd2 = create(bw,2) \nw2 = destroy(bw,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, initializing one or two-photon states in the first or second waveguide is done by:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nψ_single_1 = onephoton(bw,1,ξ,2,5)\nψ_double_1 = twophoton(bw,1,ξ2,2,5)\nψ_single_2 = onephoton(bw,2,ξ,2,5)\nψ_double_2 = twophoton(bw,2,ξ2,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we want to describe a simultaneous excitation in both waveguides (states like ket1_i_mathrm1ket1_j _mathrm2 where the subscript $\\ket{1i}\\mathrm{i}$ means waveguide i) we specify both indices of the waveguides:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ψ_single_1_and_2 = twophoton(bw,[1,2],ξ2,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/#Beamsplitter","page":"Multiple waveguides","title":"Beamsplitter","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Let's now treat the same example as in Interference on Beamsplitter. We consider the two waveguides in an identic single-photon state and thus use the above defined ψ_single_1_and_2. The Hamiltonian governing a beamsplitter in the time-binned formalism has V= pi4:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/4\nH = im*V/dt*(wd2*w1 - wd1*w2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then evolve the system under this Hamiltonian to perform the beam-splitting operation:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_out = waveguide_evolution(times,ψ_single_1_and_2,H)\n\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then view the final state to verify that we only have two photons in the same waveguide simultaneously:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_second = TwoPhotonView(psi_out,2);\npsi_first = TwoPhotonView(psi_out,1);\npsi_first_second = TwoPhotonView(psi_out,[1,2]);\nnorm(psi_second)^2\nnorm(psi_first)^2\nnorm(psi_first_second)^2","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Except for numerical errors, we have 50% chance of observing both photons in the same waveguide and 0 (8.736388404016349e-9)% of observing both photons in each of the waveguides simultaneously. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, we can plot the scattering/splitting of a single photon arriving in the left arm. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/#Swap","page":"Multiple waveguides","title":"Swap","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we instead choose V = pi  2, we get the SWAP operation. Let us consider one photon in the first waveguide and swap it to the second waveguide and animate the evolution:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/2\nH = im*V/dt*(wd2*w1 - wd1*w2)\npsi_out_swap = waveguide_evolution(times,ψ_single_1,H)\nfirst_after = OnePhotonView(psi_out_swap,1)\nsecond_after = OnePhotonView(psi_out_swap,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: \"Alt text\")","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"info: WaveguideBasis(2,2,times) vs. Waveguide $\\otimes$ Waveguide\nInstead of using the custom basis for handling two waveguides, one could instead just do a tensor product between two waveguides basis. This naive approach would look something like:times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nBtotal = bw ⊗ bwThis might work if you only consider single-photon excitations in the waveguides, but if you go consider two-photon excitations (as in the above) the Hilbert space blows up. Indeed, in the above example, the Hilbert space is of size: 27.594.009!!! However, since we often know that the system in total only has two excitations, there is no possibility of having two photons in both waveguides simultaneously (states of type: ket1_k1_j_1ket1_l1_m_2). This part of the Hilbert space takes up the majority since it scales as propto N^4 where N is the number of time-bins. Instead, we can exploit that only a total of two excitations is present simultaneously in the system. For this, we use the custom basis WaveguideBasis with an additional input stating the number of waveguides:bw = WaveguideBasis(2,2,times)The Hilbert space is now of size: 20706. This is still a large Hilbert space, but it is three orders of magnitude smaller than the naive approach as it only scales as propto N^2. ","category":"page"},{"location":"#WaveguideQED.jl","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideQED.jl is a package for simulating continuous fockstates in waveguides. It expands on QuantumOptics.jl by adding a custom basis, operators, and routines for doing detection. ","category":"page"},{"location":"#Dev-docs","page":"WaveguideQED.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideBasis for representing the waveguide Hilbert space and the related functions for generating states in this Hilbert space: zerophoton, onephoton, and twophoton. Also see OnePhotonView, TwoPhotonView, and plot_twophoton! for viewing the waveguide states and plotting them. Note that WaveguideBasis can contain multiple waveguides.\nWaveguideOperator are specialized operators allowing efficient annihilation and creation operators at each time-bin in the waveguide. They are created by giving a basis to WaveguideQED.destroy and WaveguideQED.create\nSince the interaction between the waveguide time-bin mode k and cavity/emitter is given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called CavityWaveguideOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\nDetector, LazyTensorKet, and LazySumKet, together with detect_single_click and detect_double_click allow one to do a beamsplitter interference and subsequent detection of photons coming from two waveguides. ","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"(Image: alt text)","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"DocTestSetup = quote\n    using WaveguideQED\nend","category":"page"},{"location":"detection/#BStutorial","page":"Detection and Projections","title":"Detection and Projections","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"A beamsplitter is a partly reflective, partly transmissive mirror that splits up an incoming photon, as depicted here. ","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Assuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time. This can be modeled in WaveguideQED.jl using LazyTensorKet and Detector. We start by creating the two input waveguides.   ","category":"page"},{"location":"detection/#Background-Theory","page":"Detection and Projections","title":"Background Theory","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Two photons impinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinguishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  ","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution, and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is[1]  : w_a rightarrow (w_c + w_d)sqrt(2) and w_b rightarrow (w_c - w_d)sqrt(2), where w_k is the annihilation operator for waveguide k=abcd. A one photon continuous fockstate in waveguide a and b with wavefunction xi_a(t) and xi_b(t) has the combined state:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab = ketpsi_a otimes ketpsi_b =  int_t_0^t_end mathrmdt  xi_a(t) w_a^dagger(t) ket0_a otimes int_t_0^t_end mathrmdt  xi_b(t) w_b^dagger(t) ket0_b \n int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_a^dagger(t)  w_b^dagger(t) ket0_aket0_b\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Using the beamsplitter transformation, we thus have the following state after the two photons have interfered with the beamsplitter:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab xrightarrowBS frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) (w_c^dagger(t) + w_d^dagger(t))  (w_c^dagger(t) - w_d^dagger(t)) ket0_aket0_b \n=  frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) left  w_c^dagger(t) w_c^dagger(t) + w_d^dagger(t)w_c^dagger(t) - w_c^dagger(t)w_d^dagger(t) - w_d^dagger(t)w_d^dagger(t) right  ket0_cket0_d \n= frac12 left ( W_c^dagger(xi_a) W_c^dagger(xi_b) ket0_c - W_d^dagger(xi_a) W_d^dagger(xi_b) ket0_d + int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt left  xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right ket1_cket1_d right)\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"where we introduced W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd = int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_cd^dagger(t) w_cd^dagger(t) ket0_cd. W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd thus corresponds to both photons going into the same direction. It is also evident that if xi_a(t)xi_b(t) - xi_a(t)xi_b(t) = 0 then we will have no photons in waveguide c and d simultaneously. This condition is exactly fulfilled if the photon in waveguide a is indistinguishable from the photon in waveguide b. This also means that if the photons ARE distinguishable, we will start to see photons occurring in waveguides c and d simultaneously. All this and more can be simulated in the code, and in the next section, we walk through how to set the above example up in the code.","category":"page"},{"location":"detection/#Beamsplitter-and-detection-in-WaveguideQED.jl","page":"Detection and Projections","title":"Beamsplitter and detection in WaveguideQED.jl","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"In WaveguideQED.jl we create the two incoming photons in each of their respective waveguides and define the corresponding annihilation operators:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:20\nbw = WaveguideBasis(1,times)\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,1,10)\nwaveguide_b = onephoton(bw,ξfun,1,10)\nwa = destroy(bw)\nwb = destroy(bw)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"We then combine the states of waveguide a and b in a lazy tensor structure (tensor product is never calculated, but the dimensions are inferred in subsequent calculations):","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"ψ_total = LazyTensorKet(waveguide_a,waveguide_b)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Now we define Detector operators, which define the beamsplitter and subsequent detection operation. In the following mathrmDplus = D_+ = frac1sqrt2(w_a + w_b)  and mathrmDminus = D_- = frac1sqrt2(w_a - w_b)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Dplus = Detector(wa/sqrt(2),wb/sqrt(2))\nDminus = Detector(wa/sqrt(2),-wb/sqrt(2))\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The Detector applies the first operator (wa/sqrt(2)) to the first Ket in LazyTensorKet (waveguide_a) and the second operator ($\\pm $ wb/sqrt(2)) to the second Ket in LazyTensorKet (waveguide_b). The probability of detecting a photon in the detectors can then be calculated by:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus = Dplus * ψ_total\np_minus = Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The returned probabilities are zero because there is no states that result in only ONE click at the detectors. Instead, we have to ask for the probability of detecting TWO photons:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Notice that we here asked what the probability of having a detection event in detector plus/minus and, subsequently, another detection event in detector plus/minus is. The output was 50 for both cases reflecting the above calculations where we would expect the two photons always come in pairs. As a consequence, the probability of having a click in detector plus and then in detector minus (or vice versa) is given as:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"As expected, the resulting probabilities are zero. If we instead displace the photons in time so that one is centered around t = 5 and another around t = 15 we get:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"waveguide_a = onephoton(bw,ξfun,1,5);\nwaveguide_b = onephoton(bw,ξfun,1,15);\nψ_total = LazyTensorKet(waveguide_a,waveguide_b);\np_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total\np_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Thus we have an equal probability of detection events in the same detector and opposite detectors since the two photon-pulses are temporarily separated.","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"[1]: Christopher Gerry, Peter Knight (2004)","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [WaveguideQED]\nPrivate = false","category":"page"},{"location":"API/#WaveguideQED.CavityWaveguideAbsorption","page":"API","title":"WaveguideQED.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous Cavity creation and Waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideEmission","page":"API","title":"WaveguideQED.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideOperator","page":"API","title":"WaveguideQED.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.Detector","page":"API","title":"WaveguideQED.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazySumKet","page":"API","title":"WaveguideQED.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorBra","page":"API","title":"WaveguideQED.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorKet","page":"API","title":"WaveguideQED.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView{T} <: AbstractVector{T}\n\nStructure for viewing onephoton excitations in waveguides of the form W^dagger(xi) 0 rangle = int_t_0^t_end dt  xi(t) w_mathrmi^dagger(t) emptyset rangle where i is the index of the waveguide. See onephoton on how to create onephoton wavepackets and view_waveguide on how to index when there are multiple systems.\n\nExamples\n\nusing QuantumOptics;\ntimes = 0:1:10;\nbw = WaveguideBasis(1,times);\nψ1 = onephoton(bw,x->1,norm=false);\nOnePhotonView(ψ1) == ones(length(times))\n\nbc = FockBasis(2);\nψ1Cavity = fockstate(bc,2,norm=false) ⊗ ψ1;\nOnePhotonView(ψCavity,[3,:]) == ones(length(times))\n\nbw =  WaveguideBasis(1,3,times);\nψ2 = onephoton(bw,2,x->1,norm=false)\nOnePhotonView(ψ,2) == ones(length(times))\n\nψ2Cavity = fockstate(bc,2) ⊗ ψ2;\nOnePhotonView(ψ2Cavity,2,[3,:]) == ones(length(times))\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T) where {T<:SingleWaveguideKet}\n\nψ contains only a single waveguide and no waveguide index is needed. No index of the system is provided and groundstate is assumed.  Thus returns OnePhotonView(ψ,index) with index = [1,:,1,...] with : at the location of the waveguide and 1 in every other position. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,WI::Int,index::I) where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nψ contains only a multiple waveguides and waveguide index WI is needed. index should follow syntax outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,index::I) where {T<:SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nψ contains only a single waveguide and no waveguide index is needed. index should follow syntax outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,WI::Int)  where {T<:MultipleWaveguideKet}\n\nψ contains only a multiple waveguides and waveguide index WI is needed. No index of the system is provided and groundstate is assumed (see view_waveguide). \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonTimestepView","page":"API","title":"WaveguideQED.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state. Used in mul!. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle where i and j are the indeces of the waveguide as matrix. See also twophoton and view_waveguide.\n\nExamples\n\nBasic viewing:\n\nusing LinearAlgebra; #hide\ntimes = 1:1:10;\nbw = WaveguideBasis(2,times);\nψ = twophoton(bw,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nViewing state combined with other basis:\n\nusing QuantumOptics;\nbc = FockBasis(2);\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,[3,:]);\nψview == ones((length(times),length(times)))\n\nViewing twophoton state in waveguide 2 with multiple waveguides\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,2,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ,2);\nψview == ones((length(times),length(times)))\n\nViewing twophoton state in waveguide 2 with multiple waveguides combined with other basis:\n\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,2,[3,:]);\nψview == ones((length(times),length(times)))\n\nViewing twophotons across waveguide 1 and 2\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,1,2,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ,1,2);\nψview == ones((length(times),length(times)))\n\nViewing twophotons across waveguide 1 and 2 combined with other basis:\n\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,1,2,[3,:]);\nψview == ones((length(times),length(times)))\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T) where {T <: SingleWaveguideKet}\n\nState ψ only contains one waveguide and no index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{F}, Tuple{I}, Tuple{T}, Tuple{T, F, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}, F<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::F,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}},F<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nState ψ contains multiple waveguides.\n\nWaveguide indeces provided as tuple or vector of length 2, means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI[1] and j = WI[2].\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI1::Int,WI2::Int,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ contains multiple waveguides.\n\nTwo waveguide indeces means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI1 and j = WI2.\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::Int,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ contains multiple waveguides.\n\nOnly one waveguide index i=WI means viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,index::I) where {T <: SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ only contains one waveguide. Index should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::I) where {T <: MultipleWaveguideKet,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nState ψ contains multiple waveguides.\n\nWaveguide indeces provided as tuple or vector of length 2, means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI[1] and j = WI[2].\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI1::Int,WI2::Int) where {T <: MultipleWaveguideKet}\n\nState ψ contains multiple waveguides.\n\nTwo waveguide indeces means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI1 and j = WI2.\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::Int) where {T <: MultipleWaveguideKet}\n\nState ψ contains multiple waveguides and waveguide index WI required. \n\nOnly one waveguide index i=WI means viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoWaveguideTimestepView","page":"API","title":"WaveguideQED.TwoWaveguideTimestepView","text":"TwoWaveguideTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in twophoton states in two waveguides. Used in mul!. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoWaveguideView","page":"API","title":"WaveguideQED.TwoWaveguideView","text":"TwoWaveguideView{T} <: AbstractMatrix{T}\n\nStructure for viewing state with one photon in waveguide i and j. Returned from TwoPhotonView. See also TwoPhotonView, twophoton, and view_waveguide\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideBasis","page":"API","title":"WaveguideQED.WaveguideBasis","text":"WaveguideBasis(Np,Nw, times)\nWaveguideBasis(Np, times)\n\nBasis for time binned Waveguide where Np is the number of photons in the waveguide and Nw the number of waveguides (default is 1). Currently number of photons is restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideCreate","page":"API","title":"WaveguideQED.WaveguideCreate","text":"WaveguideCreate{B1,B2,N,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching creation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideDestroy","page":"API","title":"WaveguideQED.WaveguideDestroy","text":"WaveguideDestroy{B1,B2,Np,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching annihilation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideOperator","page":"API","title":"WaveguideQED.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDestroy\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"WaveguideQED.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"WaveguideQED.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_dt-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_dt","text":"get_dt(basis::WaveguideBasis)\nget_dt(basis::Basis)\nget_dt(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}","page":"API","title":"WaveguideQED.get_number_of_waveguides","text":"get_number_of_waveguides(basis::WaveguideBasis)\nget_number_of_waveguides(basis::Basis)\nget_number_of_waveguides(basis::CompositeBasis)\n\nReturn number of waveguides Nw of WaveguideBasis{Np,Nw} given either a WaveguideBasis{Np,Nw} or a CompositeBasis containing a WaveguideBasis{Np,Nw}\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = waveguidebasis ⊗ otherbasis where waveguidebasis is a WaveguideBasis and otherbasis some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = otherbasis ⊗ waveguidebasis with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"WaveguideQED.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"WaveguideQED.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton","page":"API","title":"WaveguideQED.onephoton","text":"Create a onephoton wavepacket in waveguide of the form W^dagger(xi) 0 rangle = int_t_0^t_end dt  xi(t) w_mathrmi^dagger(t) emptyset rangle = sum_k where i is the index of the waveguide and return it as a Ket. See also WaveguideBasis and OnePhotonView for how to view the state. \n\nExamples\n\ndt = 1\ntimes = 1:dt:10;\nbw = WaveguideBasis(1,times);\nψ = onephoton(bw,x->dt,norm=false);\nOnePhotonView(ψ) == ones(length(times))\n\nvec = collect(1:1:10);\nψ = onephoton(bw,vec);\nOnePhotonView(ψ) == vec\n\nbw = WaveguideBasis(1,3,times);\nψ = onephoton(bw,2,x->dt);\nOnePhotonView(ψ,2) == ones(length(times))\n\n\n\n\n\n","category":"function"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, AbstractArray}} where {T, Nw}","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,Nw},i,ξvec;norm=true) where {T,Nw}\n\nSince b contains a Nw waveguides, the index of the waveguide needed.\ni is the index of the waveguide at which the onephoton wavepacket is created in\nξ should be AbstractArray with length(ξ) == b.nsteps\nnorm::Bool=true: If true normalize the resulting wavepacket.    \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...; norm=true) where {T,Nw}\n\nSince b contains Nw waveguides, the index of the waveguide needed.\ni is the index of the waveguide at which the onephoton wavepacket is created in\nξ should be broadcastable as ξ.(times,args...), where times  = 0:b.dt:(b.nsteps-1)*b.dt (the times used to define the waveguidebasis)\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=true: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, AbstractArray}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,1},ξ::AbstractArray;norm=true) where {T}\n\nSince b only contains a single waveguide, the index of the waveguide is not needed. \nξ should be AbstractArray with length(ξ) == b.nsteps \nnorm::Bool=true: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=True) where {T}\n\nSince b only contains a single waveguide, the index of the waveguide is not needed. \nξ should be broadcastable as ξ.(times,args...), where times  = 0:b.dt:(b.nsteps-1)*b.dt (the times used to define the waveguidebasis)\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=true: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"WaveguideQED.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times;kwargs...)\nplot_twophoton!(ax,twophotonstate::TwoWaveguideView,times;kwargs...)\nplot_twophoton!(ax,state::Ket,times;kwargs...)\nplot_twophoton!(ax,twophotonstate,times;kwargs...)\n\nPlots the twophoton state in the given ax. \n\nArguments\n\nax of type PyObject <AxesSubplot: > from PyPlot\nState to be plotted twophotonstate or state. If state is a Ket TwoPhotonView is called to extract twophotonstate. Otherwise twophotonstate should be AbstractArray of dimensions (length(times),length(times)).\n\n#Return ax.contour object with the plotted state.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"WaveguideQED.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton","page":"API","title":"WaveguideQED.twophoton","text":"Create a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle where i and j are the indeces of the waveguide and return it as a Ket.\n\nSee also WaveguideBasis and TwoPhotonView for how to view the state. \n\n#Examples  Creating twophoton state with only one waveguide (using a function):\n\nusing LinearAlgebra; #hide\ntimes = 1:1:10;\nbw = WaveguideBasis(2,times);\nψ = twophoton(bw,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nψ = twophoton(bw,(t1,t2,arg1)->arg1,123,norm=false);\nψview = TwoPhotonView(ψ);\nψview == 123*ones((length(times),length(times)))\n\n\nCreating twophoton state with only one waveguide (using a matrix):\n\nψ = twophoton(bw,ones((length(times),length(times))),norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nCreating twophoton state in waveguide 2 with multiple waveguides\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,2,(t1,t2)->1,norm=false);\n\nCreating twophoton state across waveguide 1 and 2\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,1,2,(t1,t2)->1,norm=false);\n\n\n\n\n\n","category":"function"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Function, Any, Vararg{Any}}} where {T, Nw, I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Function,times,args...;norm=true) where {T,Nw,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}} = twophoton(b,idx[1],idx[2],ξ,times,args...,norm=norm)\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\nI[1] denotes the index i of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nI[2] denotes the index j of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(times[l],times[m],args...).\ntimes: A vector or range of length(times) = b.nsteps.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Matrix}} where {T, Nw, I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Matrix;norm=true) where {T,Nw,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\nI[1] denotes the index i of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nI[2] denotes the index j of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...;norm=true) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(t1,t2,args...) where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Function,args...;norm=true) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nj denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(t1,t2,args...) where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Matrix}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Matrix;norm=true) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nj denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Matrix}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Matrix;norm=true) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=True) where {T}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains only one waveguide and no index needed.\nξ given as a function should follow  ξ(t1,t2,args...),  where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Matrix}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,1},ξ::Matrix;norm=true) where {T}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains only one waveguide and no index needed.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=true: normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"WaveguideQED.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\nusing QuantumOptics;\ntimes=0:1:10;\nbw = WaveguideBasis(1,times);\nbc = FockBasis(2);\nψ_waveguide = Ket(bw,ones(length(times)));\nψ_total = ψ_waveguide ⊗ fockstate(bc,0) ⊗ fockstate(bc,0);\nψ_view = view_waveguide(ψ_total);\nψ_view_index = view_waveguide(ψ_total,[:,1,1]);\nψ_view==ψ_view_index\n\nψ_total = ψ_waveguide ⊗ fockstate(bc,2) ⊗ fockstate(bc,1);\nview_waveguide(ψ_total,[:,3,2]) == ones(length(times))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.  If fout =1 the state psi is returned for all timesteps in a vector.  ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nReturns\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\nif fout = 1 ψ at all timesteps is returned.\n\nExamples\n\nfout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"WaveguideQED.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\nSee documentation for waveguide_evolution on how to define fout. J should be a list of collapse operators following documentation of timeevolution.mcwf_dynamic. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state  emptyset  angle\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDestroy\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"function"}]
}
