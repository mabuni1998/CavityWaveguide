var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"detection_example/#Interference-on-beamsplitter","page":"Beamsplitter","title":"Interference on beamsplitter","text":"","category":"section"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Define two waveguides each occupied by a single photon with a gaussian wavefunction ","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"times = 0:0.1:20\nbw = WaveguideBasis(1,times)\nwa = destroy(bw)\nwb = destroy(bw)\n\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,1,10,times)\nwaveguide_b = onephoton(bw,ξfun,1,10,times)\nψ_total = LazyTensorKet(waveguide_a,waveguide_b)","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Define the effect of 50/50 beamsplitter labeling the two detectors after the beamsplit \"plus\" and \"minus\"","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"detector_plus = Detector(wa/sqrt(2),wb/sqrt(2))\ndetector_minus = Detector(wa/sqrt(2),-wb/sqrt(2))","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Calculate the probability of having two clicks in plus, in click in minus or one in both:","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"p_plus_plus_click = detect_double_click(ψ_total,detector_plus,detector_plus)\np_minus_minus_click = detect_double_click(ψ_total,detector_minus,detector_minus)\np_plus_minus_click = detect_double_click(ψ_total,detector_plus,detector_minus)\np_minus_plus_click = detect_double_click(ψ_total,detector_minus,detector_plus)\n\nprintln(\"Probability of having two clicks in detector plus: $p_plus_plus_click\")\nprintln(\"Probability of having two clicks in detector minus: $p_minus_minus_click\")\nprintln(\"Probability of having one click in detector plus and one in detector minus: $(p_plus_minus_click+p_minus_plus_click)\")","category":"page"},{"location":"continous_fockstates/#Continous-Fock-States","page":"Continous Fock States","title":"Continous Fock States","text":"","category":"section"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ket0\nendequation*","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: commw(t)w(t) = delta(t-t). The probability of observing a photon at time t is given by: bra0 w(t) ketpsi = xi(t)^2. The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"The heart of the photon time binning is discretizing the continuous fock state into time bins of width Delta t. It is then assumed that an emitter/cavity will only interact with the discretized waveguide state one timebin at a time. Corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"beginequation*\n    ketpsi = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle  rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"In CavityWaveguide.jl, the timebins above are represented as elements in arrays corresponding to each timebin. Let`s say you want to represent a single photon contionous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done be first creating waveguide basis capable defined on such a timeinterval:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"julia> times = 0:0.1:10\njulia> bw = WaveguideBasis(1,times)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2) and times the time interval over which the continous fock state is defined. To define the continous fockstate we need to give a wavefuntion xi. In the following we define a gaussian wavefunction located around t=5 with a width of sigma = 2:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"julia> ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\njulia> σ,t0 = 2,5\njulia> ψ = onephoton(bw,ξ,times,σ,t0)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"This state can be visuallized by:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"julia> viewed_state = view_onephoton(ψ)\njulia> fig,ax = subplots(1,1,figsize=(9,4.5))\njulia> ax.plot(times,viewed_state,\"r-\")\njulia> ax.set_xlabel(\"Time [a.u]\")\njulia> ax.set_ylabel(L\"$\\xi(t)$\")\njulia> plt.tight_layout()","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"(Image: alt text)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"We can straightforwardly extend the above definition to a two-photon continuous state as[2]:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"The state is now defined over two times, which now describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state, and both probabilities are described by the single photon wavefunction xi(t). ","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"For the timebinning we now have:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac2sqrt2 sum_i=1^N sum_ki^N xileft(t_iright) xileft(t_kright)left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =sqrt2 sum_i=1^N sum_k  i^N xileft(t_iright) xileft(t_kright) mid 1_t_i 1_t_krangle + sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"where the sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent having one photon at time bin k and then one photon at time bin j or one photon at time bin j and then one photon at time bin k). This is how the twophoton state is saved in the underlying arrays and we can define a twophoton basis as and corresponding twophoton state as:","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"julia> bw = WaveguideBasis(2,times)\njulia> ξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\njulia> σ,t0 = 2,5\njulia> ψ = twophoton(bw,ξ2,times,σ,t0)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"Notice that we here defined a symmetric twophoton product state ","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"julia> viewed_state = view_onephoton(ψ)\njulia> fig,ax = subplots(1,1,figsize=(9,4.5))\njulia> ax.plot(times,viewed_state,\"r-\")\njulia> ax.set_xlabel(\"Time [a.u]\")\njulia> ax.set_ylabel(L\"$\\xi(t)$\")\njulia> plt.tight_layout()","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"(Image: alt text)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"continous_fockstates/","page":"Continous Fock States","title":"Continous Fock States","text":"[2]: Ben Q. Baragiola, Robert L. Cook, Agata M. Branczyk, Joshua Combes (2012)","category":"page"},{"location":"#CavityWaveguide.jl","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"","category":"section"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"CavityWaveguide.jl is a package for simulating continous fockstates in waveguides. It expands on QuantumOptics.jl by adding custom basises, operators, and routines for doing detection. ","category":"page"},{"location":"#Dev-docs","page":"CavityWaveguide.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"WaveguideBasis for representing the waveguide space and the related generator functions: zerophoton, onephoton, and twophoton. Also see view_onephoton and view_twophoton for viewing the waveguide data for plotting.\nWaveguideOperator which are specialized operators allowing efficient annihilation and creation operators at each timebin in the waveguide. They are created by giving a basis to CavityWaveguide.destroy and CavityWaveguide.create\nSince the interaction between the waveguide timebin mode k and cavity/emitter is always given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called CavityWaveguideOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\nDetector, LazyTensorKet, and LazySumKet together with detect_single_click and detect_double_click allows one to do a beamsplitter interference and subsequent detection on photons comming from two waveguides. ","category":"page"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"DocTestSetup = quote\n    using CavityWaveguide\nend","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CavityWaveguide]\nPrivate = false","category":"page"},{"location":"API/#CavityWaveguide.CavityWaveguideAbsorption","page":"API","title":"CavityWaveguide.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity creation and waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideEmission","page":"API","title":"CavityWaveguide.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideOperator","page":"API","title":"CavityWaveguide.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.Detector","page":"API","title":"CavityWaveguide.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.InputOutputTimestepView","page":"API","title":"CavityWaveguide.InputOutputTimestepView","text":"InputOutputTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in one photon input output state.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.InputOutputView","page":"API","title":"CavityWaveguide.InputOutputView","text":"InputOutputView{T} <: AbstractMatrix{T}\n\nStructure for viewing state with one photon in input and output waveguide. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazySumKet","page":"API","title":"CavityWaveguide.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazyTensorBra","page":"API","title":"CavityWaveguide.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazyTensorKet","page":"API","title":"CavityWaveguide.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.OnePhotonView-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.OnePhotonView","text":"OnePhotonView(ψ::Ket)\nOnePhotonView(ψ::Ket,type)\nOnePhotonView(ψ::Ket,index)\nOnePhotonView(ψ::Ket,index,typw)\n\nReturn a view of the onephoton mode ξ(t) given a state defined on a WaveguideBasis or InputOutputWaveguideBasis. If the state is a InputOutputWaveguideBasis the type parameter can be used to choose between the input or output mode with type = :input or type = :output    If no index is provided the ground state is returned. Index should follow same form outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.TwoPhotonTimestepView","page":"API","title":"CavityWaveguide.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.TwoPhotonView","page":"API","title":"CavityWaveguide.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory).\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideBasis","page":"API","title":"CavityWaveguide.WaveguideBasis","text":"WaveguideBasis(N, times)\n\nBasis for time binned Waveguide where N is the number of photons in the waveguide. Currently restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideCreate","page":"API","title":"CavityWaveguide.WaveguideCreate","text":"WaveguideCreate{N} <: WaveguideOperator\n\nOperator structure for dispatching creation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideDestroy","page":"API","title":"CavityWaveguide.WaveguideDestroy","text":"WaveguideDestroy{N} <: WaveguideOperator\n\nOperator structure for dispatching annihilation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideOperator","page":"API","title":"CavityWaveguide.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.absorption-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"CavityWaveguide.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"CavityWaveguide.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.emission-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"CavityWaveguide.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"CavityWaveguide.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = BW ⊗ BC where BW is a WaveguideBasis and BC some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = BC ⊗ BW with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"CavityWaveguide.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(basis::WaveguideBasis)\nget_waveguidetimeindex(basis::Basis)\nget_waveguidetimeindex(basis::CompositeBasis)\n\nReturn timeindex of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputabsorption-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.inputabsorption","text":"inputabsorption(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\ninputabsorption(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and inputdestroy(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputcreate-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.inputcreate","text":"inputcreate(basis::WaveguideBasis{N}) where N\n\nCreation operator for input waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputdestroy-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.inputdestroy","text":"inputdestroy(basis::WaveguideBasis{N})\n\nAnnihilation operator for input waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputemission-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.inputemission","text":"inputemission(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\ninputemission(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and inputcreate(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.onephoton-Tuple{InputOutputWaveguideBasis, Any, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.onephoton","text":"onephoton(b::InputOutputWaveguideBasis,ξ::Function,times,args...,norm=True)\nonephoton(b::InputOutputWaveguideBasis,ξvec;norm=true)\n\nCreate a onephoton wavepacket of the form W^dagger(xi) 0 = int_t_0^t_end dt  xi(t) w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ.(times,args...). ξvec is a vector of length: b.nsteps. If norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.onephoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.onephoton","text":"onephoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\nonephoton(b::WaveguideBasis,ξvec;norm=true)\n\nCreate a onephoton wavepacket of the form W^dagger(xi) 0 = int_t_0^t_end dt  xi(t) w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ.(times,args...). ξvec is a vector of length: b.nsteps. If norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputabsorption-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.outputabsorption","text":"outputabsorption(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\noutputabsorption(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and outputdestroy(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputcreate-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.outputcreate","text":"Outputcreate(basis::WaveguideBasis{N}) where N\n\nCreation operator for output waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputdestroy-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.outputdestroy","text":"outputdestroy(basis::WaveguideBasis{N})\n\nAnnihilation operator for output waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputemission-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.outputemission","text":"outputemission(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\noutputemission(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and outputcreate(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"CavityWaveguide.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times)\nplot_twophoton!(ax,state::Ket,times)\n\nPlots the twophoton state in the given ax. If state is a Ket view_twophoton is called to extract twophotonstate.  Returns ax.contour object.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"CavityWaveguide.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.twophoton-Tuple{InputOutputWaveguideBasis, Any, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.twophoton","text":"twophoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\ntwophoton(b::WaveguideBasis,ξvec::Matrix;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w^dagger(t)w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ(t1,t2,args...). ξvec is a matrix of dimension: (b.nsteps,b.nsteps), where ξvec[i,j] = ξ(times[i],times[j]), where times is defined in WaveguideBasis.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.twophoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.twophoton","text":"twophoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\ntwophoton(b::WaveguideBasis,ξvec::Matrix;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w^dagger(t)w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ(t1,t2,args...). ξvec is a matrix of dimension: (b.nsteps,b.nsteps), where ξvec[i,j] = ξ(times[i],times[j]), where times is defined in WaveguideBasis.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\ntimes=0:0.1:10\nbw = WaveguideBasis(2,times)\nbc1 = FockBasis(2)\nbc2 = FockBasis(2)\nψ_waveguide = onephoton(bw,x->1)\nψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1)\nψ_view = view_waveguide(ψ_total)\nψ_view_index = view_waveguide(ψ_total,[:,1,1])\nψ_view==ψ_view_index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"CavityWaveguide.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.   ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nOutput\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\n\nExample fout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"CavityWaveguide.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.zerophoton-Tuple{InputOutputWaveguideBasis}","page":"API","title":"CavityWaveguide.zerophoton","text":"zerophoton(bw::InputOutputWaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\nmul!(result::Bra{B1}, a::Bra{B2}, b::LazyTensor{B1,B2,F,I,T}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideOperator, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Bra{B1}, a::Bra{B2}, b::CavityWaveguideOperator, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator. Routine only works if [WaveguideBasis] is the first or last basis in Hilbertspace. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\ndagger(op::WaveguideCreate)\ndagger(op::WaveguideDestroy)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(op1::AbstractOperator,op2::CavityWaveguideAbsorption)\ntensor(op1::CavityWaveguideAbsorption,op2::AbstractOperator)\ntensor(op1::AbstractOperator,op2::CavityWaveguideEmission)\ntensor(op1::CavityWaveguideEmission,op2::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"function"}]
}
