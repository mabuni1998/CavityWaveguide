var documenterSearchIndex = {"docs":
[{"location":"tutorial/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In this section, we show simple examples that illustrate how to use WaveguideQED.jl in combination with QuantumOptics.jl","category":"page"},{"location":"tutorial/#combining","page":"Tutorials","title":"Combining with QuantumOptics.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Basises, states, and operators defined in WaveguideQED.jl can be effortlesly combined with operators from QuantumOptics.jl. As an example, we are going to consider a waveguide with a single photon pulse impinging on an empty onesided cavity. A sketch of the system can be seen here:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We start by defining the basis of the cavity and waveguide:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using WaveguideQED\nusing QuantumOptics\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nbc = FockBasis(1)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Next we want to create the Hamiltonian for the system. The interaction between the waveguide and cavity is at timestep k given by[1] H_k = i hbar sqrtgamma  Delta t( a^dagger w_k - a w_k^dagger), where a     (a^dagger) is the cavity annihilation (creation) operator, w_k(w_k^dagger) is the waveguide annihilation (creation) operator, gamma is the leakage rate of the cavity, and \\Delta t = times[2]-times[1] is the width of the timebin. WaveguideQED.jl follows the same syntax as QuantumOptics.jl and operators are defined from a basis. Operators of different Hilbert spaces are then combined using ⊗ (otimes):","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"a = destroy(bc)\nad = create(bc)\nw = destroy(bw)\nwd = create(bw)\ndt = times[2] - times[1]\nγ = 1\nH = im*sqrt(γ/dt)*( ad ⊗ w - a ⊗ wd  )\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With this we can now simulate the scattering of a single photon with a gaussian wavefunction scattered on a cavity. We define the initial state as waveguide state as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ_waveguide = onephoton(bw,ξ,times,σ,t0)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Assuming the cavity is empty the combined initial state is then:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_in = fockstate(bc,0) ⊗ ψ_waveguide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With the initial state we can then call the solver the get the wavefunction after the interaction with the cavity.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out = waveguide_evolution(times,ψ_in,H)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Plotting the wavefunction and its norm square gives:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using PyPlot\nviewed_state = OnePhotonView(ψ_out)\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,viewed_state,\"r-\")\nax[1].set_xlabel(\"Time [a.u]\")\nax[1].set_ylabel(L\"$\\xi(t)$\")\n\nax[2].plot(times,abs.(viewed_state).^2,\"r-\")\nax[2].set_xlabel(\"Time [a.u]\")\nax[2].set_ylabel(L\"$|\\xi(t)|^2$\")\nplt.tight_layout()\nplt.savefig(\"scat_onephoton.svg\") #hide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We see that the wavefunction has changed after the interaction with the cavity. More specifically we see how the pulse gets absorped into the cavity leading and a corresponding phase change of the wave. This phase change also leads to destructive interference between the photon being emitted from the cavity and the reflection af the incoming photon. This leads to the dip in the photon wavefunction after the interaction.","category":"page"},{"location":"tutorial/#Expectation-values","page":"Tutorials","title":"Expectation values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In the previous example, only the state at the final timestep was shown. This shows the output wavefunction, but one might also be interested in intermediate states or expectation values. Expectation values can be outputtet from the solver by using the fout keyword. As an example, we can get the number of photons in the cavity as a function of time by:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na(time,psi)\n    expect(n,psi)\nend\nψ_out,na = waveguide_evolution(times,ψ_in,H,fout=exp_na)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we also want to know the number of photons in the waveguide state as a function of time another operator to out expectation function as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nn_w = identityoperator(bc) ⊗ (create(bw)*destroy(bw))\nfunction exp_na_and_nw(time,psi)\n    (expect(n,psi),expect(n_w,psi))\nend\nψ_out,na,nw = waveguide_evolution(times,ψ_in,H,fout=exp_na_and_nw)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Where expect(n_w,psi) calculates the expectation value of all times of the pulse at each timestep: mathrmexpect(n_wpsi) = brapsi sum_k  I otimes w_k^dagger w_k  ketpsi","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"This can be plottet as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,na,\"b-\",label=\"na\")\nax.plot(times,nw,\"r-\",label=\"nw\")\nax.plot(times,nw+na,\"g-\",label=\"na+nw\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(\"Population\")\nax.legend()\nplt.tight_layout()\nplt.savefig(\"photon_number.svg\") #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Here we see how the photon wavepacket is partially absorped into the cavity and then reemitted again.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we plot the wavefunction as a function of time (and do some displacing) we can even animate the process:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"example_lodahl/#Scattering-on-two-level-system","page":"Scattering on two level system","title":"Scattering on two level system","text":"","category":"section"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"In the following, we show that with our framwework we can reproduce the theoretical results obtained in Le Jeannic, et al. Nat. Phys. 18, 1191–1195 (2022) ","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"In many of the examples considered so far, we only consider a single waveguide that serves as both input and output, thus only allowing for only one-sided cavities or quantum systems at the end of a waveguide. A more realistic scenario is having a waveguide with a quantum system in the middle. Here an incoming waveguide carying an excitation could scatter on the quantum system and one would have excitations going away from the quantum system in both the first and latter part of the waveguide as illustrated here:[1]","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"[1]: Hanna Le Jeannic, Alexey Tiranov, Jacques Carolan, Tomás Ramos, Ying Wang, Martin Hayhurst Appel, Sven Scholz, Andreas D. Wieck, Arne Ludwig, Nir Rotenberg, Leonardo Midolo, Juan José García-Ripoll, Anders S. Sørensen, Peter Lodahl (2022)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: `alt text`)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"A way to model this scenario is to have two waveguides: a waveguide to the left and the right, describing the first half of the waveguide and the latter part of the waveguide. For this we use WaveguideBasis but with an extra argument specifying that we need 2 waveguides (see Two Waveguides for an introduction). We initialize WaveguideBasis with two waveguides and a basis for the atom (note that a fockbasis with only one excitation allowed is the same as a two-level-system):","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nbw = WaveguideBasis(2,2,times)\nbe = FockBasis(1)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"We then define the operators for the interaction between atom and waveguide as (notice the second argument in create(bw,1) that defines which waveguide we are adressing):","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"wdLa = create(bw,1) ⊗ destroy(be)\nadwL = destroy(bw,1) ⊗ create(be)\nwdRa = create(bw,2) ⊗ destroy(be)\nadwR = destroy(bw,2) ⊗ create(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"where mathrmwdLa = w_L ^dagger a, mathrmwdRa = w_R ^dagger a, mathrmadwL = w_L  a^dagger, and mathrmadwR = w_R  a^dagger. In this example, we, however, also need an interaction between the waveguides. We therefore we define the creation and annihilation operators ","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"wdL = create(bw,1) ⊗ identityoperator(be)\nwL = destroy(bw,1) ⊗ identityoperator(be)\nwdR = create(bw,2) ⊗ identityoperator(be)\nwR = destroy(bw,2) ⊗ identityoperator(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"The interaction should carry over the momentum of the left pulse into the right waveguide and the interaction should therefore model a SWAP gate. This corresponds to V = pi 2 and thus we have the interaction Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"V = pi/2\nκ1 = 1\nκ2 = 1\nH = im*sqrt(κ1/dt)*(adwL-wdLa) + im*sqrt(κ2/dt)*(wdRa-adwR) + V/dt *(wdR*wL + wdL* wR)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"We can now study how single or two photon states scatter on the atom. We define the initial onephoton or twophoton gaussian state and solve it using the defined Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ξ₁(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξ₂(t1,t2,σ1,σ2,t0) = ξ₁(t1,σ1,t0) * ξ₁(t2,σ2,t0) \nw = 1\nt0 = 5\nψ1 = onephoton(bw,1,ξ₁,times,w,t0) ⊗ fockstate(be,0)\nψ2 = twophoton(bw,1,ξ₂,times,w,w,t0) ⊗ fockstate(be,0)\nψScat1 = waveguide_evolution(times,ψ1,H)\nψScat2 = waveguide_evolution(times,ψ2,H)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"Viewing the scattered states is then done using TwoPhotonView and the index for the corresponding waveguide. Giving two indeces returns instead the combined single photon state in both waveguides sum_jk ket1_j_1 ket1_k_2:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ψ2LeftScat = TwoPhotonView(ψScat2,[:,1],1)\nψ2RightScat = TwoPhotonView(ψScat2,[:,1],2)\nψ2LeftRightScat = TwoPhotonView(ψScat2,[:,1],2,1)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"For the single photon states we have to calculate the two time scattered distribution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"ψ1LeftScat = zeros(ComplexF64,(length(times),length(times)))\nψ1RightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1LeftRightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1Right = OnePhotonView(ψScat1,[:,1],2)\nψ1Left = OnePhotonView(ψScat1,[:,1],1)\n\nfor i in eachindex(times)\n    for j in eachindex(times)\n        ψ1LeftScat[i,j] = ψ1Left[i]*ψ1Left[j]\n        ψ1RightScat[i,j] = ψ1Right[i]*ψ1Right[j]\n        ψ1LeftRightScat[i,j] = ψ1Left[i]*ψ1Right[j]\n    end\nend\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"Finall, this can be plotted and we note that this matches fig. 3 in Ref. ^[1]:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"using PyPlot; #hide\nfig,axs = subplots(3,2,figsize=(9,17))\nplot_list = [ψ2RightScat,ψ2LeftScat,ψ2LeftRightScat,ψ1RightScat,ψ1LeftScat,ψ1LeftRightScat]\nfor (i,ax) in enumerate(axs)\n    plot_twophoton!(ax,plot_list[i],times)\nend\naxs[1].set_ylabel(\"\\$C^{RR}\\$ \\n t2 [a.u]\")\naxs[2].set_ylabel(\"\\$C^{LL}\\$ \\n t2 [a.u]\")\naxs[3].set_ylabel(\"\\$C^{LR}\\$ \\n t2 [a.u]\")\naxs[3].set_xlabel(\"t1 [a.u]\")\naxs[6].set_xlabel(\"t1 [a.u]\")\nplt.tight_layout()\nplt.savefig(\"lodahl_fig3.svg\") #hide\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: lodahl)","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"If we consider the single photon state, we can also visualize the temporal evolution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on two level system","title":"Scattering on two level system","text":"(Image: alt text)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"theoreticalbackground/#Theoretical-Background","page":"Theoretical Background","title":"Theoretical Background","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In this section, we go over the necessary theory to work with continous fockstates in the WaveguideQED.jl","category":"page"},{"location":"theoreticalbackground/#Continous-Fock-States","page":"Theoretical Background","title":"Continous Fock States","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: leftw(t)w(t)right  = delta(t-t). The probability of observing a photon at time t is given by: bra0 w(t) ketpsi = xi(t)^2. The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The heart of the photon time binning is discretizing the continuous fock state into time bins of width Delta t. The interaction with the emitter/cavity will is then assumed to span only one timebin at a time, corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. We denote the action of the discretized creation operator as: w_kdagger ketemptyset = ket1_k meaning a single photon in timebin k. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In WaveguideQED.jl, the timebins above are represented as elements in arrays corresponding to each timebin:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Let`s say you want to represent a single photon contionous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done be first creating waveguide basis defined on such a timeinterval:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using WaveguideQED\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2) and times the time interval over which the continous fock state is defined. To define the continous fockstate we need to give a wavefuntion xi. In the following we define a gaussian wavefunction located around t=5 with a width of sigma = 1:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ = onephoton(bw,ξ,times,σ,t0)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This state can be visuallized by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using PyPlot\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\");\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()\nplt.savefig(\"one_continous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The timebinned creation and annihilation operators are easily created from the basis:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w = destroy(bw)\nwd = create(bw)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The timebin that the operator acts on is set by either:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w.timeindex = 10\nwd.timeindex = 10\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"or:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(w,10)\nset_waveguidetimeindex!(wd,10)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The effect of the creation operator is to create a photon in timebin k and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This is also seen if we plot the creation operator acting on the vacuum:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ψ = wd*zerophoton(bw)\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\");\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()\nplt.savefig(\"created_onephoton_continous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We see a spike around t = times[10] = 0.9 where we now created an excitation. In itself, the waveguide basis, states, and operators are not particularly interesting, but when combined with other quantum mechanical systems such as cavities and emitters the framework can produce powerfull results. See the next example of how to combine with quantum systems defined in 'QuantumOptics.jl'","category":"page"},{"location":"theoreticalbackground/#Continous-two-photon-fock-states","page":"Theoretical Background","title":"Continous two-photon fock states","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"So far we have considered only one excitation in the waveguide. We can extend the definition of a one-photon continous fock state to a two-photon state as[2]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we here defined the two photon wavefunction xi^(2)(tt) = xi(t) xileft(t^primeright). The state is now defined over two times, which describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state xi^(2)(tt) = xi(t) xileft(t^primeright), and both probabilities are described by the (same) single photon wavefunction xi(t), but one could have entangled states across time. This means a non-seperable wavefunction xi^(2)(tt) neq xi_1(t)xi_2(t). For now we will consider a symmetric and seperable state.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The timebinning is in a similar fashion defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac2sqrt2 sum_i=1^N sum_ki^N xileft(t_iright) xileft(t_kright)left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =sqrt2 sum_i=1^N sum_k  i^N xileft(t_iright) xileft(t_kright) mid 1_t_i 1_t_krangle + sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent having one photon at time bin k and then one photon at time bin j or one photon at time bin j and then one photon at time bin k). This is how the twophoton state is saved in the underlying arrays and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Creating then is:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We can define a twophoton basis and corresponding operator by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"bw = WaveguideBasis(2,times)\nwd = create(bw)\nprintln(pwd())\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The creation operator can then be visualized by acting on a onephoton state with ones all over. This is seen in the following. Note that the state is visualized as a contour plot mirrored around the diagonal.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(wd,50)\npsi_plot = wd*onephoton(bw,x->1,times)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,psi_plot,times)\nplt.savefig(\"twophoton_created.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"If we want to create a twophotn gaussian state we instead do:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ = twophoton(bw,ξ2,times,σ,t0)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we defined the two photon equivalent of our single photon gaussian state. When we visualize it, we now need two times, and we make a contour plot. This is easily done viewing the twophoton state: ","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"viewed_state = TwoPhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,viewed_state,times)\nax.set_ylabel(\"time [1/γ]\")\nax.set_xlabel(\"time [1/γ]\") \nplt.tight_layout()\nplt.savefig(\"two_continous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[2]: Ben Q. Baragiola, Robert L. Cook, Agata M. Branczyk, Joshua Combes (2012)","category":"page"},{"location":"multiplewaveguides/#Multiple-waveguides","page":"Multiple waveguides","title":"Multiple waveguides","text":"","category":"section"},{"location":"multiplewaveguides/#twowaveguide","page":"Multiple waveguides","title":"Two Waveguides","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"In the previous examples, we have only considered cases with a single waveguide. In this tutorial, we show how to model a beamsplitter and an optical switch using two waveguides. A beamsplitter or a swap gate can be modelled using the Hamiltonian H_I = V(w_1^dagger w_2 + w_2^dagger w_1) where V is some interaction strength that determines which interaction is moddeled (we will discuss this in detail later). w_1 and w_2 is the annihilation operators of the two waveguides. A sketch of the system can be seen here:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can describe the state of two waveguides with a total of N excitations by adding an argument specifying the number of waveguides as:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nNPhotons = 2\nNWaveguides = 2\nbw = WaveguideBasis(NPhotons,NWaveguides,times)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"When creating operators, we now have to specify which waveguide they are acting on (in this case number one or two). This is done by an extra argument to create and destroy:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"wd1 = create(bw,1)\nw1 = destroy(bw,1)\nwd2 = create(bw,2) \nw2 = destroy(bw,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, initializing one or two photon states in the first or second waveguide is done by:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nψ_single_1 = onephoton(bw,1,ξ,times,2,5)\nψ_double_1 = twophoton(bw,1,ξ2,times,2,5)\nψ_single_2 = onephoton(bw,2,ξ,times,2,5)\nψ_double_2 = twophoton(bw,2,ξ2,times,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we want to describe a simultanous excitation in both waveguides (states like ket1_i_mathrm1ket1_j _mathrm2 where the subscript $\\ket{1i}\\mathrm{i}$ means waveguide i) we specify both indeces of the waveguides:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ψ_single_1_and_2 = twophoton(bw,[1,2],ξ2,times,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/#Beamsplitter","page":"Multiple waveguides","title":"Beamsplitter","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Let's now treat the same example as in Interference on Beamsplitter. We consider the two waveguides in a identic single photon state and thus use the above defined ψ_single_1_and_2. The Hamiltonian governing a beamsplitter in the time binned formalism has V= pi4:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/4\nH = im*V/dt*(wd2*w1 - wd1*w2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then evolve the system under this Hamiltonian to perform the beamsplitting operation:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_out = waveguide_evolution(times,ψ_single_1_and_2,H)\n\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then view the final state to verify that we only have twophotons in the same waveguide simultanouesly:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_second = TwoPhotonView(psi_out,2);\npsi_first = TwoPhotonView(psi_out,1);\npsi_first_second = TwoPhotonView(psi_out,[1,2]);\nnorm(psi_second)^2\nnorm(psi_first)^2\nnorm(psi_first_second)^2","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Except for numerical errors we thus have 50% chance of observing both photons in the same waveguide and 0 (8.736388404016349e-9)% of observing both photons in each of the waveguide simultanoues. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, we can plot the scattering / splitting of a single photon arriving in the left arm. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/#Swap","page":"Multiple waveguides","title":"Swap","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we instead choose V = pi  2 we get the SWAP operation. Let us consider one photon in the first waveguide and swap it to second waveguide and animate the evolution:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/2\nH = im*V/dt*(wd2*w1 - wd1*w2)\npsi_out_swap = waveguide_evolution(times,ψ_single_1,H)\nfirst_after = OnePhotonView(psi_out_swap,1)\nsecond_after = OnePhotonView(psi_out_swap,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: \"Alt text\")","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"info: WaveguideBasis(2,2,times) vs. Waveguide $\\otimes$ Waveguide\nInstead of using the custom basis for handling two waveguides, one could instead just do a tensor product between two waveguides basises. This naive approach would look something like:times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nBtotal = bw ⊗ bw\nnothing #hideThis might work if you only consider single photon excitations in the waveguides, but if you go consider two photon excitations (as in the above) the hilbert space blows up. Indeed, in the above example, the hilbert space is of size: 27.594.009!!! However, since we often know that the system in total only has two excitations, there is no possibility of having two photons in both waveguides simultanously (states of type: ket1_k1_j_1ket1_l1_m_2). This part of the Hilber space takes up the majority since it scales as propto N^4 where N is the number of timebins. Instead we can exploit that only a total of two excitations is present simultanosly in the system. For this we use the custom basis WaveguideBasis with an addination input stating the number of waveguides:bw = WaveguideBasis(2,2,times)\nnothing #hideThe hilbert space is now of size: 20706, this is of course still large Hilbert space, but 3 orders of magnitude smaller than the naive approach as it still only scales as propto N^2. ","category":"page"},{"location":"#WaveguideQED.jl","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideQED.jl is a package for simulating continous fockstates in waveguides. It expands on QuantumOptics.jl by adding custom basises, operators, and routines for doing detection. ","category":"page"},{"location":"#Dev-docs","page":"WaveguideQED.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideBasis for representing the waveguide space and the related generator functions: zerophoton, onephoton, and twophoton. Also see OnePhotonView, TwoPhotonView, and plot_twophoton! for viewing the waveguide data for plotting. Note that WaveguideBasis can contain multiple waveguides.\nWaveguideOperator which are specialized operators allowing efficient annihilation and creation operators at each timebin in the waveguide. They are created by giving a basis to WaveguideQED.destroy and WaveguideQED.create\nSince the interaction between the waveguide timebin mode k and cavity/emitter is always given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called CavityWaveguideOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\nDetector, LazyTensorKet, and LazySumKet together with detect_single_click and detect_double_click allows one to do a beamsplitter interference and subsequent detection on photons comming from two waveguides. ","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"(Image: alt text)","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"DocTestSetup = quote\n    using WaveguideQED\nend","category":"page"},{"location":"detection/#BStutorial","page":"Detection and Projections","title":"Detection and Projections","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"A beamsplitter is a partly reflective partly transmitive mirror that splits up an incomming photon as depicted here.","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Asuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time. This can be modeled in WaveguideQED.jl using LazyTensorKet and Detector. We start by creating the two input waveguides.   ","category":"page"},{"location":"detection/#Background-Theory","page":"Detection and Projections","title":"Background Theory","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Two photons inpinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinquishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  ","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is[1]  : w_a rightarrow (w_c + w_d)sqrt(2) and w_b rightarrow (w_c - w_d)sqrt(2), where w_k is the annihilation operator for waveguide k=abcd. A one photon continous fockstate in waveguide a and b with wavefunction xi_a(t) and xi_b(t) has the combined state:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab = ketpsi_a otimes ketpsi_b =  int_t_0^t_end mathrmdt  xi_a(t) w_a^dagger(t) ket0_a otimes int_t_0^t_end mathrmdt  xi_b(t) w_b^dagger(t) ket0_b \n int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_a^dagger(t)  w_b^dagger(t) ket0_aket0_b\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Using the beamsplitter transformation, we thus have the following state after the two photons have interfered on the beamsplitter:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab xrightarrowBS frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) (w_c^dagger(t) + w_d^dagger(t))  (w_c^dagger(t) - w_d^dagger(t)) ket0_aket0_b \n=  frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) left  w_c^dagger(t) w_c^dagger(t) + w_d^dagger(t)w_c^dagger(t) - w_c^dagger(t)w_d^dagger(t) - w_d^dagger(t)w_d^dagger(t) right  ket0_cket0_d \n= frac12 left ( W_c^dagger(xi_a) W_c^dagger(xi_b) ket0_c - W_d^dagger(xi_a) W_d^dagger(xi_b) ket0_d + int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt left  xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right ket1_cket1_d right)\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"where we introduced W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd = int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_cd^dagger(t) w_cd^dagger(t) ket0_cd. W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd thus corresponds to both photons going into the same direction. It is also evident that if xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right = 0 then we will have no photons in waveguide c and d simultanously. This condition is exactly fulfilled if the photon in waveguide a is indistinquishable from the photon in waveguide b. This also means that if the photons ARE distinquishable, we will start to see photon occuring in waveguide c and d simultanously. All this and more can be simulated in the code and in the next section we walk through how to set the above example up in the code.","category":"page"},{"location":"detection/#Beamsplitter-and-detection-in-WaveguideQED.jl","page":"Detection and Projections","title":"Beamsplitter and detection in WaveguideQED.jl","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"In CaviyWaveguide.jl we create the two incoming photons in each of their respective waveguides and define the corresponding annihilation operators:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:20\nbw = WaveguideBasis(1,times)\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,times,1,10)\nwaveguide_b = onephoton(bw,ξfun,times,1,10)\nwa = destroy(bw)\nwb = destroy(bw)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"We then combine the states of waveguide a and b in a lazy tensor structure (tensor product is never calculated but the dimensions are inferred in subsequent calculations):","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"ψ_total = LazyTensorKet(waveguide_a,waveguide_b)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Now we define Detector operators, which defines the beamsplitter and subsequent detection operation. In the following mathrmDplus = D_+ = frac1sqrt2(w_a + w_b)  and mathrmDminus = D_- = frac1sqrt2(w_a - w_b)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Dplus = Detector(wa/sqrt(2),wb/sqrt(2))\nDminus = Detector(wa/sqrt(2),-wb/sqrt(2))\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The Detector applies the first operator (wa/sqrt(2)) to the first Ket in LazyTensorKet (waveguide_a) and the second operator (L$\\pm$ wb/sqrt(2)) to the second Ket in LazyTensorKet (waveguide_b). The probability of detecting a photon in the detectors can then be calculated by:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus = Dplus * ψ_total\np_minus = Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The returned probabilities are zero because there is no states that result in only ONE click at the detectors. Instead we have to ask for the probability of detecting TWO photons:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Notice that we here asked what is the probability of having a detection event in detector plus/minus and subsequently another detection event in detector plus/minus. The output was 50 for both cases reflecting the above calculations where we would expect the two photons always come in pairs. As a consequence the probability of having a click in detector plus and then in detector minus (or vice versa) is given as:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"As expected the resulting probabilities are zero. If we instead displace the photons in time so that one is centered around t = 5 and another around t = 15 we get:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"waveguide_a = onephoton(bw,ξfun,times,1,5);\nwaveguide_b = onephoton(bw,ξfun,times,1,15);\nψ_total = LazyTensorKet(waveguide_a,waveguide_b);\np_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total\np_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Thus we have an equal probability detection events in the same detector and in opposite detectors, since the two photon pulse are temporaly seperated.","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"[1]: Christopher Gerry, Peter Knight (2004)","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [WaveguideQED]\nPrivate = false","category":"page"},{"location":"API/#WaveguideQED.CavityWaveguideAbsorption","page":"API","title":"WaveguideQED.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous Cavity creation and Waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideEmission","page":"API","title":"WaveguideQED.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideOperator","page":"API","title":"WaveguideQED.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.Detector","page":"API","title":"WaveguideQED.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazySumKet","page":"API","title":"WaveguideQED.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorBra","page":"API","title":"WaveguideQED.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorKet","page":"API","title":"WaveguideQED.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T) where {T<:SingleWaveguideKet}\nOnePhotonView(ψ::T,index::I) where {T<:SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\nOnePhotonView(ψ::T,WI::Int)  where {T<:MultipleWaveguideKet}\nOnePhotonView(ψ::T,index::I,WI::Int) where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nReturn a view of the onephoton wavefunction ξ(t) given a state containing a WaveguideBasis. If the WaveguideBasis contains more than one waveguide, a waveguide index WI is required to indicate which waveguide is viewed (1,2,3,... etc.)   If the state contains more basises (e.g. a cavity) index used to indicate which state should be viewed. Index should follow same form outlined in view_waveguide and if not given the groundstate is assummed.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonTimestepView","page":"API","title":"WaveguideQED.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory).\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T) where {T <: SingleWaveguideKet}\nTwoPhotonView(ψ::T,index::I) where {T <: SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\nTwoPhotonView(ψ::T,WI::Int) where {T <: MultipleWaveguideKet}\nTwoPhotonView(ψ::T,WI1::Int,WI2::Int) where {T <: MultipleWaveguideKet}\nTwoPhotonView(ψ::T,WI::I) where {T <: MultipleWaveguideKet,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\nTwoPhotonView(ψ::T,index::I,WI::Int)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nReturn a view of the twophoton wavefunction ξ(t1t2) given a state containing a WaveguideBasis. If the WaveguideBasis contains more than one waveguide, a waveguide index WI is required to indicate which waveguide is viewed. WI follows the same syntax  outlined in twophoton for more information on how to view the state. If the state contains more basises (e.g. a cavity) index used to indicate which state should be viewed. Index should follow same form outlined in view_waveguide and if not given the groundstate is assummed.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoWaveguideTimestepView","page":"API","title":"WaveguideQED.TwoWaveguideTimestepView","text":"TwoWaveguideTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in one photon Left Right state.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoWaveguideView","page":"API","title":"WaveguideQED.TwoWaveguideView","text":"TwoWaveguideView{T} <: AbstractMatrix{T}\n\nStructure for viewing state with one photon in Left and Right waveguide. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideBasis","page":"API","title":"WaveguideQED.WaveguideBasis","text":"WaveguideBasis(Np,Nw, times)\naveguideBasis(Np, times)\n\nBasis for time binned Waveguide where Np is the number of photons in the waveguide and Nw the number of waveguides (default is 1). . Currently number of photons is restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideCreate","page":"API","title":"WaveguideQED.WaveguideCreate","text":"WaveguideCreate{B1,B2,N,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching creation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideDestroy","page":"API","title":"WaveguideQED.WaveguideDestroy","text":"WaveguideDestroy{B1,B2,Np,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching annihilation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideOperator","page":"API","title":"WaveguideQED.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate{B,B,Np,i} <: WaveguideOperator\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDesroy{B,B,Np,i} <: WaveguideOperator\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"WaveguideQED.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"WaveguideQED.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}","page":"API","title":"WaveguideQED.get_number_of_waveguides","text":"get_number_of_waveguides(basis::WaveguideBasis)\nget_number_of_waveguides(basis::Basis)\nget_number_of_waveguides(basis::CompositeBasis)\n\nReturn number of waveguides Nw of WaveguideBasis{Np,Nw} given either a WaveguideBasis{Np,Nw} or a CompositeBasis containing a WaveguideBasis{Np,Nw}\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = waveguidebasis ⊗ otherbasis where waveguidebasis is a WaveguideBasis and otherbasis some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = otherbasis ⊗ waveguidebasis with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"WaveguideQED.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"WaveguideQED.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,1},ξ::Function,times,args...,norm=True) where {T}\nonephoton(b::WaveguideBasis{T,1},ξvec;norm=true) where {T}\nonephoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,times,args...; norm=true) where {T,Nw}\nonephoton(b::WaveguideBasis{T,Nw},i,ξvec;norm=true) where {T,Nw}\n\nCreate a onephoton wavepacket in waveguide of the form W^dagger(xi) 0 rangle = int_t_0^t_end dt  xi(t) w_mathrmi^dagger(t) emptyset rangle.\n\nArguments\n\nb::WaveguideBasis{T,Nw}: the basis of the waveguides, where T is the number of photons in the waveguides and Nw is the number of waveguides.\ni::Int (optional): the index of the waveguide where the photon is created. If not provided, i=1 is assumed.\nξ::Function or ξ::AbstractArray: the wavefunction of the state. Can be a function with structure ξ.(times,args...) or an AbstractArray of length b.nsteps.\ntimes: A vector or range of times where the wavefunction is evaluated, used only if ξ is a function.\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=true: normalize the resulting wavepacket.\n\nReturns\n\n[Ket(b)]: a ket with the wavefunction defined above.\n\nIf b only contains one waveguide, the output wavefunction will contain on excitation in the Waveguide (i=1). If b contains multiple waveguides and only one index is given (i or j), then i=j is assumed.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"WaveguideQED.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times)\nplot_twophoton!(ax,twophotonstate::TwoWaveguideView,times)\nplot_twophoton!(ax,state::Ket,times)\nplot_twophoton!(ax,twophotonstate,times)\n\nPlots the twophoton state in the given ax. \n\nArguments\n\nax of type PyObject <AxesSubplot: > from PyPlot\nState to be plotted twophotonstate or state. If state is a Ket TwoPhotonView is called to extract twophotonstate. Otherwise twophotonstate should be AbstractArray of dimensions (length(times),length(times)).\n\n#Return ax.contour object with the plotted state.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"WaveguideQED.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,1},ξ::Function,times,args...,norm=True) where {T}\ntwophoton(b::WaveguideBasis{T,1},ξvec::Matrix;norm=true) where {T}\ntwophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,times,args...;norm=true) where {T,Nw}\ntwophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Matrix;norm=true) where {T,Nw}\ntwophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Function,times,args...;norm=true) where {T,Nw}\ntwophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Matrix;norm=true) where {T,Nw}\ntwophoton(b::WaveguideBasis{T,Nw},WI::I,ξ::Matrix;norm=true) where {T,Nw,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\ntwophoton(b::WaveguideBasis{T,Nw},WI::I,ξ::Function,times,args...;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\n\nArguments\n\nb::WaveguideBasis{T,Nw}: the basis of the waveguides, where T is the number of photons in the waveguides and Nw is the number of waveguides.\ni::Int (optional): the index of the waveguide where the first photon is created. If not provided, i=1 is assumed.\nj::Int (optional): the index of the waveguide where the second photon is created. If not provided, j=i is assumed.\nξ::Function or ξ::Matrix: the wavefunction of the state. Can be a function with structure ξ(times[l],times[m],args...) or a matrix of dimension (b.nsteps, b.nsteps).\ntimes: A vector or range of times where the wavefunction is evaluated, used only if ξ is a function.\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=true: normalize the resulting wavepacket.\n\nReturns\n\n[Ket(b)]: a ket with the wavefunction defined above.\n\nIf b only contains one waveguide, the output wavefunction will contain two excitations in the same waveguide (i=j=1). If b contains multiple waveguides and only one index is given (i or j), then i=j is assumed, and two excitations in the same waveguide are returned. i and j can also be given as a tuple or vector WI= (i,j) or WI= [i,j]\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"WaveguideQED.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\njulia> using WaveguideQED; #hide\njulia> using QuantumOptics; #hide\njulia> times=0:0.1:10;\njulia> bw = WaveguideBasis(2,times);\njulia> bc1 = FockBasis(2);\njulia> bc2 = FockBasis(2);\njulia> ψ_waveguide = onephoton(bw,x->1);\njulia> ψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1);\njulia> ψ_view = view_waveguide(ψ_total);\njulia> ψ_view_index = view_waveguide(ψ_total,[:,1,1]);\njulia> ψ_view==ψ_view_index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.  If fout =1 the state psi is returned for all timesteps in a vector.  ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nReturns\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\nif fout = 1 ψ at all timesteps is returned.\n\nExample fout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"WaveguideQED.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\nSee documentation for waveguide_evolution. J should be a list of collapse operators. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate{B,B,Np,i} <: WaveguideOperator\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDesroy{B,B,Np,i} <: WaveguideOperator\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"function"}]
}
