var documenterSearchIndex = {"docs":
[{"location":"toturial_combining/#combining","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"","category":"section"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Basises, states, and operators defined in WaveguideQED.jl can be effortlesly combined with operators from QuantumOptics.jl. As an example, we are going to consider a waveguide with a single photon pulse impinging on an empty onesided cavity. A sketch of the system can be seen here:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"We start by defining the basis of the cavity and waveguide:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"using WaveguideQED\nusing QuantumOptics\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nbc = FockBasis(1)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Next we want to create the Hamiltonian for the system. The interaction between the waveguide and cavity is at timestep k given by[1] H_k = i hbar sqrtgamma  Delta t( a^dagger w_k - a w_k^dagger), where a     (a^dagger) is the cavity annihilation (creation) operator, w_k(w_k^dagger) is the waveguide annihilation (creation) operator, gamma is the leakage rate of the cavity, and \\Delta t = times[2]-times[1] is the width of the timebin. WaveguideQED.jl follows the same syntax as QuantumOptics.jl and operators are defined from a basis. Operators of different Hilbert spaces are then combined using ⊗ (otimes):","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"a = destroy(bc)\nad = create(bc)\nw = destroy(bw)\nwd = create(bw)\ndt = times[2] - times[1]\nγ = 1\nH = im*sqrt(γ/dt)*( ad ⊗ w - a ⊗ wd  )","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"With this we can now simulate the scattering of a single photon with a gaussian wavefunction scattered on a cavity. We define the initial state as waveguide state as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ_waveguide = onephoton(bw,ξ,times,σ,t0)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Assuming the cavity is empty the combined initial state is then:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ψ_in = fockstate(bc,0) ⊗ ψ_waveguide","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"With the initial state we can then call the solver the get the wavefunction after the interaction with the cavity.","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ψ_out = waveguide_evolution(times,ψ_in,H)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Plotting the wavefunction and its norm square gives:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"using PyPlot\nviewed_state = OnePhotonView(ψ_out)\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,viewed_state,\"r-\")\nax[1].set_xlabel(\"Time [a.u]\")\nax[1].set_ylabel(L\"$\\xi(t)$\")\n\nax[2].plot(times,abs.(viewed_state).^2,\"r-\")\nax[2].set_xlabel(\"Time [a.u]\")\nax[2].set_ylabel(L\"$|\\xi(t)|^2$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"We see that the wavefunction has changed after the interaction with the cavity. More specifically we see how the pulse gets absorped into the cavity leading and a corresponding phase change of the wave. This phase change also leads to destructive interference between the photon being emitted from the cavity and the reflection af the incoming photon. This leads to the dip in the photon wavefunction after the interaction.","category":"page"},{"location":"toturial_combining/#Expectation-values","page":"Combining with QuantumOptics.jl","title":"Expectation values","text":"","category":"section"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"In the previous example, only the state at the final timestep was shown. This shows the output wavefunction, but one might also be interested in intermediate states or expectation values. Expectation values can be outputtet from the solver by using the fout keyword. As an example, we can get the number of photons in the cavity as a function of time by:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na(time,psi)\n    expect(n,psi)\nend\nψ_out,na = waveguide_evolution(times,ψ_in,H,fout=exp_a)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"If we also want to know the number of photons in the waveguide state as a function of time, we can add norm(OnePhotonView(psi))^2 to our expectation function as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na_and_nw(time,psi)\n    (expect(n,psi),norm(OnePhotonView(psi))^2)\nend\nψ_out,na,nw = waveguide_evolution(times,ψ_in,H,fout=exp_na_and_nw)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Which we can plot as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,na,\"b-\",label=\"na\")\nax.plot(times,nw,\"r-\",label=\"nw\")\nax.plot(times,nw+na,\"g-\",label=\"na+nw\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(\"Population\")\nplt.tight_layout()","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Here we see how the photon wavepacket is partially absorped into the cavity and then reemitted again.","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"We if we plot the wavefunction as a function of time (and do some displacing) we can even animate the process:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"example_lodahl/#Multiple-Waveguides","page":"Input output waveguides","title":"Multiple Waveguides","text":"","category":"section"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"In the following, we show that with our framwework we can reproduce the theoretical results obtained in Le Jeannic, et al. Nat. Phys. 18, 1191–1195 (2022) ","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"In many of the examples considered so far, we only consider a single waveguide that serves as both input and output, thus only allowing for only one-sided cavities or quantum systems at the end of a waveguide. A more realistic scenario is having a waveguide with a quantum system in the middle. Here an incoming waveguide carying an excitation could scatter on the quantum system and one would have excitations going away from the quantum system in both the first and latter part of the waveguide as illustrated here:^[1]","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"[1]: Hanna Le Jeannic, Alexey Tiranov, Jacques Carolan, Tomás Ramos, Ying Wang, Martin Hayhurst Appel, Sven Scholz, Andreas D. Wieck, Arne Ludwig, Nir Rotenberg, Leonardo Midolo, Juan José García-Ripoll, Anders S. Sørensen, Peter Lodahl (2022)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"(Image: `alt text`)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"A way to model this scenario is to have two waveguides: a waveguide to the left and the right, describing the first half of the waveguide and the latter part of the waveguide. For this we use WaveguideBasis but with an extra argument specifying that we need 2 waveguides (see Two Waveguides for an introduction). We initialize WaveguideBasis with two waveguides and a basis for the atom (note that a fockbasis with only one excitation allowed is the same as a two-level-system):","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"bw = WaveguideBasis(2,2,times)\nbe = FockBasis(1)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"We then define the operators for the interaction between atom and waveguide as (notice the second argument in create(bw,1) that defines which waveguide we are adressing):","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"wdLa = create(bw,1) ⊗ destroy(be)\nadwL = destroy(bw,1) ⊗ create(be)\nwdRa = create(bw,2) ⊗ destroy(be)\nadwR = destroy(bw,2) ⊗ create(be)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"where mathrmwdLa = w_L ^dagger a, mathrmwdRa = w_R ^dagger a, mathrmadwL = w_L  a^dagger, and mathrmadwR = w_R  a^dagger. In this example, we, however, also need an interaction between the waveguides. We therefore we define the creation and annihilation operators ","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"wdL = create(bw,1) ⊗ identityoperator(be)\nwL = destroy(bw,1) ⊗ identityoperator(be)\nwdR = create(bw,2) ⊗ identityoperator(be)\nwR = destroy(bw,2) ⊗ identityoperator(be)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"The interaction should carry over the momentum of the left pulse into the right waveguide and the interaction should therefore model a SWAP gate. This corresponds to V = pi 2 and thus we have the interaction Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"V = pi/2\nH = im*sqrt(κ1/dt)*(adwL-wdLa) + im*sqrt(κ2/dt)*(wdRa-adwR) + V/dt *(wdR*wL + wdL* wR)\n","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"We can now study how single or two photon states scatter on the atom. We define the initial onephoton or twophoton gaussian state:","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"ξ_one_fun(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξfun(t1,t2,σ1,σ2,t0) = ξ_one_fun(t1,σ1,t0) * ξ_one_fun(t2,σ2,t0) \nw = 1\nt0 = 5\npsi_in = twophoton(bw,1,ξfun,times,w,w,t0) ⊗ fockstate(be,0)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"Then solving and viewing the twophoton states in the left,right and twophoton in left and right simultaniously:","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"psi_L_scat = TwoPhotonView(psi_out,[:,1],1)\npsi_R_scat = TwoPhotonView(psi_out,[:,1],2)\npsi_R_L_scat = TwoPhotonView(psi_out,[:,1],2,1)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"(Image: alt text)","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"We can also repeat for only a single excitation where we can plot the scattering:","category":"page"},{"location":"example_lodahl/","page":"Input output waveguides","title":"Input output waveguides","text":"(Image: alt text)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"detection_example/#Interference-on-beamsplitter","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"","category":"section"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"Define two waveguides each occupied by a single photon with a gaussian wavefunction ","category":"page"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"times = 0:0.1:20\nbw = WaveguideBasis(1,times)\nwa = destroy(bw)\nwb = destroy(bw)\n\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,1,10,times)\nwaveguide_b = onephoton(bw,ξfun,1,10,times)\nψ_total = LazyTensorKet(waveguide_a,waveguide_b)","category":"page"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"Define the effect of 50/50 beamsplitter labeling the two detectors after the beamsplit \"plus\" and \"minus\"","category":"page"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"detector_plus = Detector(wa/sqrt(2),wb/sqrt(2))\ndetector_minus = Detector(wa/sqrt(2),-wb/sqrt(2))","category":"page"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"Calculate the probability of having two clicks in plus, in click in minus or one in both:","category":"page"},{"location":"detection_example/","page":"Interference on beamsplitter","title":"Interference on beamsplitter","text":"p_plus_plus_click = detect_double_click(ψ_total,detector_plus,detector_plus)\np_minus_minus_click = detect_double_click(ψ_total,detector_minus,detector_minus)\np_plus_minus_click = detect_double_click(ψ_total,detector_plus,detector_minus)\np_minus_plus_click = detect_double_click(ψ_total,detector_minus,detector_plus)\n\nprintln(\"Probability of having two clicks in detector plus: $p_plus_plus_click\")\nprintln(\"Probability of having two clicks in detector minus: $p_minus_minus_click\")\nprintln(\"Probability of having one click in detector plus and one in detector minus: $(p_plus_minus_click+p_minus_plus_click)\")","category":"page"},{"location":"toturial_continous_fockstates/#Continous-Fock-States","page":"Continous one Photon Fock States","title":"Continous Fock States","text":"","category":"section"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ket0\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: leftw(t)w(t)right  = delta(t-t). The probability of observing a photon at time t is given by: bra0 w(t) ketpsi = xi(t)^2. The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The heart of the photon time binning is discretizing the continuous fock state into time bins of width Delta t. The interaction with the emitter/cavity will is then assumed to span only one timebin at a time, corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    ketpsi = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ket0 rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"In WaveguideQED.jl, the timebins above are represented as elements in arrays corresponding to each timebin. Let`s say you want to represent a single photon contionous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done be first creating waveguide basis defined on such a timeinterval:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using WaveguideQED\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2) and times the time interval over which the continous fock state is defined. To define the continous fockstate we need to give a wavefuntion xi. In the following we define a gaussian wavefunction located around t=5 with a width of sigma = 1:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ = onephoton(bw,ξ,times,σ,t0)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"This state can be visuallized by:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using PyPlot\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The timebinned creation and annihilation operators are easily created from the basis:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"w = destroy(bw)\nwd = create(bw)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The timebin that the operator acts on is set by either:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"w.timeindex = 10\nwd.timeindex = 10","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"or:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"set_waveguidetimeindex!(w,10)\nset_waveguidetimeindex!(wd,10)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The effect of the operator is clear if used on a vacuum state and plot the state we get:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using PyPlot\nψ = wd*zerohpoton(bw)\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"We see a spike around t = times[10] = 0.9 where we now created an excitation. In itself, the waveguide basis, states, and operators are not particularly interesting, but when combined with other quantum mechanical systems such as cavities and emitters the framework can produce powerfull results. See the next example of how to combine with quantum systems defined in 'QuantumOptics.jl'","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"toturial_detection/#BStoturial","page":"Beamsplitter interference","title":"Interference on Beamsplitter","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"A beamsplitter is a partly reflective partly transmitive mirror that splits up an incomming photon as depicted here.","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"(Image: beamsplitter)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Asuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time. This can be modeled in WaveguideQED.jl using LazyTensorKet and Detector. We start by creating the two input waveguides.   ","category":"page"},{"location":"toturial_detection/#Background-Theory","page":"Beamsplitter interference","title":"Background Theory","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Two photons inpinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinquishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  ","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"(Image: beamsplitter)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is[1]  : w_a rightarrow (w_c + w_d)sqrt(2) and w_b rightarrow (w_c - w_d)sqrt(2), where w_k is the annihilation operator for waveguide k=abcd. A one photon continous fockstate in waveguide a and b with wavefunction xi_a(t) and xi_b(t) has the combined state:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"beginalign*\nketpsi_ab = ketpsi_a otimes ketpsi_b =  int_t_0^t_end mathrmdt  xi_a(t) w_a^dagger(t) ket0_a otimes int_t_0^t_end mathrmdt  xi_b(t) w_b^dagger(t) ket0_b \n int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_a^dagger(t)  w_b^dagger(t) ket0_aket0_b\nendalign*","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Using the beamsplitter transformation, we thus have the following state after the two photons have interfered on the beamsplitter:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"beginalign*\nketpsi_ab xrightarrowBS frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) (w_c^dagger(t) + w_d^dagger(t))  (w_c^dagger(t) - w_d^dagger(t)) ket0_aket0_b \n=  frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) left  w_c^dagger(t) w_c^dagger(t) + w_d^dagger(t)w_c^dagger(t) - w_c^dagger(t)w_d^dagger(t) - w_d^dagger(t)w_d^dagger(t) right  ket0_cket0_d \n= frac12 left ( W_c^dagger(xi_a) W_c^dagger(xi_b) ket0_c - W_d^dagger(xi_a) W_d^dagger(xi_b) ket0_d + int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt left  xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right ket1_cket1_d right)\nendalign*","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"where we introduced W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd = int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_cd^dagger(t) w_cd^dagger(t) ket0_cd. W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd thus corresponds to both photons going into the same direction. It is also evident that if xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right = 0 then we will have no photons in waveguide c and d simultanously. This condition is exactly fulfilled if the photon in waveguide a is indistinquishable from the photon in waveguide b. This also means that if the photons ARE distinquishable, we will start to see photon occuring in waveguide c and d simultanously. All this and more can be simulated in the code and in the next section we walk through how to set the above example up in the code.","category":"page"},{"location":"toturial_detection/#Beamsplitter-and-detection-in-WaveguideQED.jl","page":"Beamsplitter interference","title":"Beamsplitter and detection in WaveguideQED.jl","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"In CaviyWaveguide.jl we create the two incoming photons in each of their respective waveguides and define the corresponding annihilation operators:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"times = 0:0.1:20\nbw = WaveguideBasis(1,times)\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,times,1,10)\nwaveguide_b = onephoton(bw,ξfun,times,1,10)\nwa = destroy(bw)\nwb = destroy(bw)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"We then combine the states of waveguide a and b in a lazy tensor structure (tensor product is never calculated but the dimensions are inferred in subsequent calculations):","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"ψ_total = LazyTensorKet(waveguide_a,waveguide_b)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Now we define Detector operators, which defines the beamsplitter and subsequent detection operation. In the following mathrmDplus = D_+ = frac1sqrt2(w_a + w_b)  and mathrmDminus = D_- = frac1sqrt2(w_a - w_b)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Dplus = Detector(wa/sqrt(2),wb/sqrt(2))\nDminus = Detector(wa/sqrt(2),-wb/sqrt(2))","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"The Detector applies the first operator (wa/sqrt(2)) to the first Ket in LazyTensorKet (waveguide_a) and the second operator (L$\\pm$ wb/sqrt(2)) to the second Ket in LazyTensorKet (waveguide_b). The probability of detecting a photon in the detectors can then be calculated by:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"julia> p_plus = Dplus * ψ_total\njulia> p_minus = Dminus * ψ_total\n0.0\n0.0","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"The returned probabilities are zero because there is no states that result in only ONE click at the detectors. Instead we have to ask for the probability of detecting TWO photons:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"julia> p_plus_plus = Dplus * Dplus * ψ_total\njulia> p_minus_minus = Dminus * Dminus * ψ_total\n0.4999999999999984\n0.4999999999999984","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Notice that we here asked what is the probability of having a detection event in detector plus/minus and subsequently another detection event in detector plus/minus. The output was 50 for both cases reflecting the above calculations where we would expect the two photons always come in pairs. As a consequence the probability of having a click in detector plus and then in detector minus (or vice versa) is given as:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"julia> p_plus_minus = Dplus * Dminus * ψ_total\njulia> p_minus_plus = Dminus * Dplus * ψ_total\n0.0\n0.0","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"As expected the resulting probabilities are zero. If we instead displace the photons in time so that one is centered around t = 5 and another around t = 15 we get:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"waveguide_a = onephoton(bw,ξfun,times,1,5)\nwaveguide_b = onephoton(bw,ξfun,times,1,15)\nψ_total = LazyTensorKet(waveguide_a,waveguide_b)\njulia> p_plus_plus = Dplus * Dplus * ψ_total\njulia> p_minus_minus = Dminus * Dminus * ψ_total\njulia> p_plus_minus = Dplus * Dminus * ψ_total\njulia> p_minus_plus = Dminus * Dplus * ψ_total\n0.24999999999999967\n0.24999999999999967\n0.24999999999999967\n0.24999999999999967","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Thus we have an equal probability detection events in the same detector and in opposite detectors, since the two photon pulse are temporaly seperated.","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"[1]: Christopher Gerry, Peter Knight (2004)","category":"page"},{"location":"toturial_twochannels/#twowaveguide","page":"Two Waveguides","title":"Two Waveguides","text":"","category":"section"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"In the previous examples, we have only considered cases with a single waveguide. In this toturial, we show how to model a beamsplitter and an optical switch using two waveguides. A beamsplitter or a swap gate can be modelled using the Hamiltonian H = V(w_a^dagger w_b + w_b^dagger w_a) where V is some interaction strength that determines which interaction is moddeled (we will discuss this in detail later). w_a and w_b is the annihilation operators of the two waveguides. We can describe the state of two waveguides with a total of N excitations by adding an argument specifying the number of waveguides as:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"times = 0:0.1:10\nNPhotons = 2\nNWaveguides = 2\nbw_twophotons = WaveguideBasis(NPhotons,NWaveguides,times)","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"When creating operators, we now have to specify which waveguide they are acting on (in this case number one or two). This is done by an extra argument to create and destroy:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"wdL = create(bw,1)\nwL = destroy(bw,1)\nwdR = create(bw,2) \nwR = destroy(bw,2)","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"Similarly, initializing one or two photon states in the first or second waveguide is done by:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nψ_single_first = onephoton(bw,1,ξ,times,2,5)\nψ_double_first = twophoton(bw,1,ξ2,times,2,5)\nψ_single_second = onephoton(bw,2,ξ,times,2,5)\nψ_double_second = twophoton(bw,2,ξ2,times,2,5)","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"If we want to describe a simultanous excitation in both waveguides (states like ket1_i_mathrmleftket1_j _mathrmright) we specify both indeces of the waveguides:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"ψ_single_first_and_second = twophoton(bw,[1,2],ξ2,times,2,5)","category":"page"},{"location":"toturial_twochannels/#Beamsplitter","page":"Two Waveguides","title":"Beamsplitter","text":"","category":"section"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"Let's now treat the same example as in Interference on Beamsplitter. We consider the two waveguides in a identic single photon state and thus use the above defined ψ_single_first_and_second. The Hamiltonian governing a beamsplitter in the time binned formalism has V= pi4:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"V = pi/4\nH = im*V/dt*(wdR*wL - wdL*wR)","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"We can then evolve the system under this Hamiltonian to perform the beamsplitting operation:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"psi_out = waveguide_evolution(times,ψ_single_first_and_second,H)","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"We can then view the final state to verify that we only have twophotons in the same waveguide simultanouesly:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"psi_second = TwoPhotonView(psi_out,2)\npsi_first = TwoPhotonView(psi_out,1)\npsi_first_second = TwoPhotonView(psi_out,[1,2])\njulia> norm(psi_R)^2\njulia> norm(psi_L)^2\njulia> norm(psi_LR)^2\n0.49999981822067935\n0.49999981822067935\n8.736388404016349e-7","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"Except for numerical errors we thus have 50% chance of observing both photons in the same waveguide and 0 (8.736388404016349e-9)% of observing both photons in each of the waveguide simultanoues. ","category":"page"},{"location":"toturial_twochannels/#Swap","page":"Two Waveguides","title":"Swap","text":"","category":"section"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"If we instead choose V = pi  2 we get the SWAP operation. Let us consider on photons in the left waveguide and swap them to right waveguide and plot before and after:","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"V = pi/2\nH = im*V/dt*(wdR*wL - wdL*wR)\npsi_out_swap = waveguide_evolution(times,ψ_single_first,H)\nfirst_before = OnePhotonView(ψ_single_first,1)\nsecond_before = OnePhotonView(ψ_single_first,2)\nfirst_after = OnePhotonView(psi_out_swap,1)\nsecond_after = OnePhotonView(psi_out_swap,2)\n\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,first_before,\"r-\",label=\"First\")\nax[1].plot(times,second_before,\"b-\",label=\"Second\")\nax[2].plot(times,first_after,\"r-\")\nax[2].plot(times,second_after,\"b-\")\n\nax[1].legend(loc=\"lower left\")\nax[1].set_title(\"Before\")\nax[1].set_xlabel(\"time [a.u]\")\nax[1].set_ylabel(\"ξ(t)\")\n\nax[2].set_title(\"After\")\nax[2].set_xlabel(\"time [a.u]\")\n\nplt.tight_layout()","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"(Image: \"Alt text\")","category":"page"},{"location":"toturial_twochannels/","page":"Two Waveguides","title":"Two Waveguides","text":"info: WaveguideBasis(2,2,times) vs. Waveguide $\\otimes$ Waveguide\nInstead of using the custom basis for handling two waveguides, one could instead just do a tensor product between two waveguides basises. This naive approach would look something like:times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nBtotal = bw ⊗ bwThis might work if you only consider single photon excitations in the waveguides, but if you go consider two photon excitations (as in the above) the hilbert space blows up. Indeed, in the above example, the hilbert space is of size: 27.594.009!!! However, since we often know that the system in total only has two excitations, there is no possibility of having two photons in both waveguides simultanously (states of type: ket1_k1_j_leftket1_l1_m_right). This part of the Hilber space takes up the majority since it scales as propto N^4 where N is the number of timebins. Instead we can exploit that only a total of two excitations is present simultanosly in the system. For this we use the custom basis WaveguideBasis with an addination input stating the number of waveguides:bw = WaveguideBasis(2,2,times)The hilbert space is now of size: 20706, this is of course still large Hilbert space, but 3 orders of magnitude smaller than the naive approach as it still only scales as propto N^2. ","category":"page"},{"location":"#WaveguideQED.jl","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideQED.jl is a package for simulating continous fockstates in waveguides. It expands on QuantumOptics.jl by adding custom basises, operators, and routines for doing detection. ","category":"page"},{"location":"#Dev-docs","page":"WaveguideQED.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideBasis for representing the waveguide space and the related generator functions: zerophoton, onephoton, and twophoton. Also see OnePhotonView, TwoPhotonView, and plot_twophoton! for viewing the waveguide data for plotting. Note that WaveguideBasis can contain multiple waveguides.\nWaveguideOperator which are specialized operators allowing efficient annihilation and creation operators at each timebin in the waveguide. They are created by giving a basis to WaveguideQED.destroy and WaveguideQED.create\nSince the interaction between the waveguide timebin mode k and cavity/emitter is always given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called WaveguideQEDOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\nDetector, LazyTensorKet, and LazySumKet together with detect_single_click and detect_double_click allows one to do a beamsplitter interference and subsequent detection on photons comming from two waveguides. ","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"DocTestSetup = quote\n    using WaveguideQED\nend","category":"page"},{"location":"toturial_2time_continous/#Continous-two-photon-fock-states","page":"Continous Two Photon Fock States","title":"Continous two photon fock states","text":"","category":"section"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"So far we have considered only one excitation in the waveguide. We can extend the definition of a one-photon continous fock state to a two-photon state as[1]:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"Here, we here defined the two photon wavefunction xi^(2)(tt) = xi(t) xileft(t^primeright). The state is now defined over two times, which describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state xi^(2)(tt) = xi(t) xileft(t^primeright), and both probabilities are described by the (same) single photon wavefunction xi(t), but one could have entangled states across time. This means a non-seperable wavefunction xi^(2)(tt) neq xi_1(t)xi_2(t). For now we will consider a symmetric and seperable state.","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"The timebinning is in a similar fashion defined as:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac2sqrt2 sum_i=1^N sum_ki^N xileft(t_iright) xileft(t_kright)left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =sqrt2 sum_i=1^N sum_k  i^N xileft(t_iright) xileft(t_kright) mid 1_t_i 1_t_krangle + sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"The sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent having one photon at time bin k and then one photon at time bin j or one photon at time bin j and then one photon at time bin k). This is how the twophoton state is saved in the underlying arrays and we can define a twophoton basis as and corresponding twophoton state as:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"bw = WaveguideBasis(2,times)\nξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ = twophoton(bw,ξ2,times,σ,t0)","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"Here, we defined the two photon equivalent of our single photon gaussian state. When we visualize it, we now need two times, and we make a contour plot. This is easily done viewing the twophoton state: ","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"using PyPlot\nviewed_state = TwoPhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,viewed_state,times)\nax.set_ylabel(\"time [1/γ]\")\nax.set_xlabel(\"time [1/γ]\") \nplt.tight_layout()","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_2time_continous/#Scattering-on-a-cavity","page":"Continous Two Photon Fock States","title":"Scattering on a cavity","text":"","category":"section"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"We now repeat the same setup as in Combining with QuantumOptics.jl but instead with a twophoton pulse scattering on the cavity. COMING UP!","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"[1]: Ben Q. Baragiola, Robert L. Cook, Agata M. Branczyk, Joshua Combes (2012)","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [WaveguideQED]\nPrivate = false","category":"page"},{"location":"API/#WaveguideQED.CavityWaveguideAbsorption","page":"API","title":"WaveguideQED.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity creation and waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideEmission","page":"API","title":"WaveguideQED.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideOperator","page":"API","title":"WaveguideQED.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.Detector","page":"API","title":"WaveguideQED.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazySumKet","page":"API","title":"WaveguideQED.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorBra","page":"API","title":"WaveguideQED.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorKet","page":"API","title":"WaveguideQED.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis}}}, Np}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::Ket)\nOnePhotonView(ψ::Ket,type)\nOnePhotonView(ψ::Ket,index)\nOnePhotonView(ψ::Ket,index,typw)\n\nReturn a view of the onephoton mode ξ(t) given a state defined on a WaveguideBasis or LeftRightWaveguideBasis. If the state is a LeftRightWaveguideBasis the type parameter can be used to choose between the Left or Right mode with type = :Left or type = :Right    If no index is provided the ground state is returned. Index should follow same form outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonTimestepView","page":"API","title":"WaveguideQED.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory).\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoWaveguideTimestepView","page":"API","title":"WaveguideQED.TwoWaveguideTimestepView","text":"TwoWaveguideTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in one photon Left Right state.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideBasis","page":"API","title":"WaveguideQED.WaveguideBasis","text":"WaveguideBasis(N, times)\n\nBasis for time binned Waveguide where N is the number of photons in the waveguide. Currently restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideCreate","page":"API","title":"WaveguideQED.WaveguideCreate","text":"WaveguideCreate{N} <: WaveguideOperator\n\nOperator structure for dispatching creation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideDestroy","page":"API","title":"WaveguideQED.WaveguideDestroy","text":"WaveguideDestroy{N} <: WaveguideOperator\n\nOperator structure for dispatching annihilation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideOperator","page":"API","title":"WaveguideQED.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"WaveguideQED.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"WaveguideQED.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = BW ⊗ BC where BW is a WaveguideBasis and BC some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = BC ⊗ BW with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"WaveguideQED.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"WaveguideQED.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguidetimeindex-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_waveguidetimeindex","text":"get_waveguidetimeindex(basis::WaveguideBasis)\nget_waveguidetimeindex(basis::Basis)\nget_waveguidetimeindex(basis::CompositeBasis)\n\nReturn timeindex of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\nonephoton(b::WaveguideBasis,ξvec;norm=true)\n\nCreate a onephoton wavepacket of the form W^dagger(xi) 0 = int_t_0^t_end dt  xi(t) w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ.(times,args...). ξvec is a vector of length: b.nsteps. If norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"WaveguideQED.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times)\nplot_twophoton!(ax,state::Ket,times)\n\nPlots the twophoton state in the given ax. If state is a Ket TwoPhotonView is called to extract twophotonstate.  Returns ax.contour object.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"WaveguideQED.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Any, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\ntwophoton(b::WaveguideBasis,ξvec::Matrix;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w^dagger(t)w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ(t1,t2,args...). ξvec is a matrix of dimension: (b.nsteps,b.nsteps), where ξvec[i,j] = ξ(times[i],times[j]), where times is defined in WaveguideBasis.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"WaveguideQED.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\ntimes=0:0.1:10\nbw = WaveguideBasis(2,times)\nbc1 = FockBasis(2)\nbc2 = FockBasis(2)\nψ_waveguide = onephoton(bw,x->1)\nψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1)\nψ_view = view_waveguide(ψ_total)\nψ_view_index = view_waveguide(ψ_total,[:,1,1])\nψ_view==ψ_view_index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.   ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nOutput\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\n\nExample fout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"WaveguideQED.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\nmul!(result::Bra{B1}, a::Bra{B2}, b::LazyTensor{B1,B2,F,I,T}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmmul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator. Routine only works if [WaveguideBasis] is the first or last basis in Hilbertspace.     dims = basis(result).shape     n = length(dims)     iter = a.indexing.iter     idxvec1=a.indexing.idxvec1     idxvec2=a.indexing.idxvec2     rangeidx = a.indexing.rangeidx\n\nidx_vec1[i] = 1\nidx_vec2[i] = 2\nstride = linear_index(n,idx_vec2,strides)- linear_index(n,idx_vec1,strides)\nidx_vec2[i] = 1\nif length(iter) == 0\n    end_idx = dims[i]\n    for k in 1:dims[j]-1\n        idx_vec1[j] = k\n        idx_vec2[j] = k+1\n        li1 = linear_index(n,idx_vec1,strides)\n        li2 = linear_index(n,idx_vec2,strides)\n        waveguide_mul!(view(result.data,li1:stride:li1+(end_idx-1)*stride),a.op,view(b.data,li2:stride:li2+(end_idx-1)*stride),sqrt(k)*a.factor*alpha,beta)\n    end\n    idx_vec1[j] = dims[j]\n    li1 = linear_index(n,idx_vec1,strides)\n    rmul!(view(result.data,li1:stride:li1+(end_idx-1)*stride),beta)\nelse\n    for k in 1:dims[j]-1\n        idx_vec1[j] = k\n        idx_vec2[j] = k+1\n        iterate_over_iter!(result.data,b.data,a,sqrt(k)*a.factor*alpha,beta,iter,idx_vec1,idx_vec2,range_idx,1,stride,dims[i],dims)\n    end\n    idx_vec1[j] = dims[j]\n    iterate_rmul!(result.data,beta,iter,idx_vec1,range_idx,1,stride,dims[i],dims)\nend\nreturn result\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"WaveguideQED.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"function"}]
}
