var documenterSearchIndex = {"docs":
[{"location":"toturial_combining/#combining","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"","category":"section"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Basises, states, and operators defined in CavityWaveguide.jl can be effortlesly combined with operators from QuantumOptics.jl. As an example, we are going to consider a waveguide with a single photon pulse impinging on an empty onesided cavity. A sketch of the system can be seen here:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"We start by defining the basis of the cavity and waveguide:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"using CavityWaveguide\nusing QuantumOptics\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nbc = FockBasis(1)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Next we want to create the Hamiltonian for the system. The interaction between the waveguide and cavity is at timestep k given by[1] H_k = i hbar sqrtgamma  Delta t( a^dagger w_k - a w_k^dagger), where a     (a^dagger) is the cavity annihilation (creation) operator, w_k(w_k^dagger) is the waveguide annihilation (creation) operator, gamma is the leakage rate of the cavity, and \\Delta t = times[2]-times[1] is the width of the timebin. CavityWaveguide.jl follows the same syntax as QuantumOptics.jl and operators are defined from a basis. Operators of different Hilbert spaces are then combined using ⊗ (otimes):","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"a = destroy(bc)\nad = create(bc)\nw = destroy(bw)\nwd = create(bw)\ndt = times[2] - times[1]\nγ = 1\nH = im*sqrt(γ/dt)*( ad ⊗ w - a ⊗ wd  )","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"With this we can now simulate the scattering of a single photon with a gaussian wavefunction scattered on a cavity. We define the initial state as waveguide state as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ_waveguide = onephoton(bw,ξ,times,σ,t0)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Assuming the cavity is empty the combined initial state is then:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ψ_in = fockstate(bc,0) ⊗ ψ_waveguide","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"With the initial state we can then call the solver the get the wavefunction after the interaction with the cavity.","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"ψ_out = waveguide_evolution(times,ψ_in,H)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Plotting the wavefunction and its norm square gives:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"using PyPlot\nviewed_state = OnePhotonView(ψ_out)\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,viewed_state,\"r-\")\nax[1].set_xlabel(\"Time [a.u]\")\nax[1].set_ylabel(L\"$\\xi(t)$\")\n\nax[2].plot(times,abs.(viewed_state).^2,\"r-\")\nax[2].set_xlabel(\"Time [a.u]\")\nax[2].set_ylabel(L\"$|\\xi(t)|^2$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"We see that the wavefunction has changed after the interaction with the cavity. More specifically we see how the pulse gets absorped into the cavity leading and a corresponding phase change of the wave. This phase change also leads to destructive interference between the photon being emitted from the cavity and the reflection af the incoming photon. This leads to the dip in the photon wavefunction after the interaction.","category":"page"},{"location":"toturial_combining/#Expectation-values","page":"Combining with QuantumOptics.jl","title":"Expectation values","text":"","category":"section"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"In the previous example, only the state at the final timestep was shown. This shows the output wavefunction, but one might also be interested in intermediate states or expectation values. Expectation values can be outputtet from the solver by using the fout keyword. As an example, we can get the number of photons in the cavity as a function of time by:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na(time,psi)\n    expect(n,psi)\nend\nψ_out,na = waveguide_evolution(times,ψ_in,H,fout=exp_a)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"If we also want to know the number of photons in the waveguide state as a function of time, we can add norm(OnePhotonView(psi))^2 to our expectation function as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na_and_nw(time,psi)\n    (expect(n,psi),norm(OnePhotonView(psi))^2)\nend\nψ_out,na,nw = waveguide_evolution(times,ψ_in,H,fout=exp_na_and_nw)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Which we can plot as:","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,na,\"b-\",label=\"na\")\nax.plot(times,nw,\"r-\",label=\"nw\")\nax.plot(times,nw+na,\"g-\",label=\"na+nw\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(\"Population\")\nplt.tight_layout()","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"(Image: alt text)","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"Here we see how the photon wavepacket is partially absorped into the cavity and then reemitted again.","category":"page"},{"location":"toturial_combining/","page":"Combining with QuantumOptics.jl","title":"Combining with QuantumOptics.jl","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"detection_example/#Interference-on-beamsplitter","page":"Beamsplitter","title":"Interference on beamsplitter","text":"","category":"section"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Define two waveguides each occupied by a single photon with a gaussian wavefunction ","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"times = 0:0.1:20\nbw = WaveguideBasis(1,times)\nwa = destroy(bw)\nwb = destroy(bw)\n\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,1,10,times)\nwaveguide_b = onephoton(bw,ξfun,1,10,times)\nψ_total = LazyTensorKet(waveguide_a,waveguide_b)","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Define the effect of 50/50 beamsplitter labeling the two detectors after the beamsplit \"plus\" and \"minus\"","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"detector_plus = Detector(wa/sqrt(2),wb/sqrt(2))\ndetector_minus = Detector(wa/sqrt(2),-wb/sqrt(2))","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"Calculate the probability of having two clicks in plus, in click in minus or one in both:","category":"page"},{"location":"detection_example/","page":"Beamsplitter","title":"Beamsplitter","text":"p_plus_plus_click = detect_double_click(ψ_total,detector_plus,detector_plus)\np_minus_minus_click = detect_double_click(ψ_total,detector_minus,detector_minus)\np_plus_minus_click = detect_double_click(ψ_total,detector_plus,detector_minus)\np_minus_plus_click = detect_double_click(ψ_total,detector_minus,detector_plus)\n\nprintln(\"Probability of having two clicks in detector plus: $p_plus_plus_click\")\nprintln(\"Probability of having two clicks in detector minus: $p_minus_minus_click\")\nprintln(\"Probability of having one click in detector plus and one in detector minus: $(p_plus_minus_click+p_minus_plus_click)\")","category":"page"},{"location":"toturial_continous_fockstates/#Continous-Fock-States","page":"Continous one Photon Fock States","title":"Continous Fock States","text":"","category":"section"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ket0\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: leftw(t)w(t)right  = delta(t-t). The probability of observing a photon at time t is given by: bra0 w(t) ketpsi = xi(t)^2. The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The heart of the photon time binning is discretizing the continuous fock state into time bins of width Delta t. The interaction with the emitter/cavity will is then assumed to span only one timebin at a time, corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"beginequation*\n    ketpsi = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ket0 rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"In CavityWaveguide.jl, the timebins above are represented as elements in arrays corresponding to each timebin. Let`s say you want to represent a single photon contionous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done be first creating waveguide basis defined on such a timeinterval:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using CavityWaveguide\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2) and times the time interval over which the continous fock state is defined. To define the continous fockstate we need to give a wavefuntion xi. In the following we define a gaussian wavefunction located around t=5 with a width of sigma = 1:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ = onephoton(bw,ξ,times,σ,t0)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"This state can be visuallized by:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using PyPlot\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The timebinned creation and annihilation operators are easily created from the basis:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"w = destroy(bw)\nwd = create(bw)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The timebin that the operator acts on is set by either:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"w.timeindex = 10\nwd.timeindex = 10","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"or:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"set_waveguidetimeindex!(w,10)\nset_waveguidetimeindex!(wd,10)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"The effect of the operator is clear if used on a vacuum state and plot the state we get:","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"using PyPlot\nψ = wd*zerohpoton(bw)\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,viewed_state,\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"We see a spike around t = times[10] = 0.9 where we now created an excitation. In itself, the waveguide basis, states, and operators are not particularly interesting, but when combined with other quantum mechanical systems such as cavities and emitters the framework can produce powerfull results. See the next example of how to combine with quantum systems defined in 'QuantumOptics.jl'","category":"page"},{"location":"toturial_continous_fockstates/","page":"Continous one Photon Fock States","title":"Continous one Photon Fock States","text":"[1]: Mikkel Heuck, Kurt Jacobs, Dirk R. Englund (2020)","category":"page"},{"location":"toturial_detection/#Interference-on-Beamsplitter","page":"Beamsplitter interference","title":"Interference on Beamsplitter","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"A beamsplitter is a partly reflective partly transmitive mirror that splits up an incomming photon as depicted here.","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"(Image: beamsplitter)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Asuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time.  ","category":"page"},{"location":"toturial_detection/#Background-Theory","page":"Beamsplitter interference","title":"Background Theory","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Two photons inpinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinquishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  ","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"(Image: beamsplitter)","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is[1]  : w_a rightarrow (w_c + w_d)sqrt(2) and w_b rightarrow (w_c - w_d)sqrt(2), where w_k is the annihilation operator for waveguide k=abcd. A one photon continous fockstate in waveguide a and b with wavefunction xi_a(t) and xi_b(t) has the combined state:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"beginalign*\nketpsi_ab = ketpsi_a otimes ketpsi_b =  int_t_0^t_end mathrmdt  xi_a(t) w_a^dagger(t) ket0_a otimes int_t_0^t_end mathrmdt  xi_b(t) w_b^dagger(t) ket0_b \n int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_a^dagger(t)  w_b^dagger(t) ket0_aket0_b\nendalign*","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"Using the beamsplitter transformation, we thus have the following state after the two photons have interfered on the beamsplitter:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"beginalign*\nketpsi_ab rightarrowBS frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) (w_c^dagger(t) + w_d^dagger(t))  (w_c^dagger(t) - w_d^dagger(t)) ket0_aket0_b \n=  frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) left  w_c^dagger(t) w_c^dagger(t) + w_d^dagger(t)w_c^dagger(t) - w_c^dagger(t)w_d^dagger(t) - w_d^dagger(t)w_d^dagger(t) right  ket0_cket0_d \n= frac12 left ( W_c^dagger(xi_a) W_c^dagger(xi_b) ket0_c - W_d^dagger(xi_a) W_d^dagger(xi_b) ket0_d + int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt left  xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right ket1_cket1_d right)\nendalign*","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"where we introduced W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd = int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_cd^dagger(t) w_cd^dagger(t) ket0_cd. W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd thus corresponds to both photons going into the same direction. It is also evident that if xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right = 0 then we will have no photons in waveguide c and d simultanously. This condition is exactly fulfilled if the photon in waveguide a is indistinquishable from the photon in waveguide b. This also means that if the photons ARE distinquishable, we will start to see photon occuring in waveguide c and d simultanously. All this and more can be simulated in the code and in the next section we walk through how to set the above example up in the code.","category":"page"},{"location":"toturial_detection/#Beamsplitter-and-detection-in-CavityWaveguide.jl","page":"Beamsplitter interference","title":"Beamsplitter and detection in CavityWaveguide.jl","text":"","category":"section"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"In CaviyWaveguide.jl we create the two incoming photons in each of their respective waveguide:","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"","category":"page"},{"location":"toturial_detection/","page":"Beamsplitter interference","title":"Beamsplitter interference","text":"[1]: Christopher Gerry, Peter Knight (2004)","category":"page"},{"location":"#CavityWaveguide.jl","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"","category":"section"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"CavityWaveguide.jl is a package for simulating continous fockstates in waveguides. It expands on QuantumOptics.jl by adding custom basises, operators, and routines for doing detection. ","category":"page"},{"location":"#Dev-docs","page":"CavityWaveguide.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"WaveguideBasis for representing the waveguide space and the related generator functions: zerophoton, onephoton, and twophoton. Also see OnePhotonView, TwoPhotonView, and plot_twophoton! for viewing the waveguide data for plotting.\nWaveguideOperator which are specialized operators allowing efficient annihilation and creation operators at each timebin in the waveguide. They are created by giving a basis to CavityWaveguide.destroy and CavityWaveguide.create\nSince the interaction between the waveguide timebin mode k and cavity/emitter is always given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called CavityWaveguideOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\nDetector, LazyTensorKet, and LazySumKet together with detect_single_click and detect_double_click allows one to do a beamsplitter interference and subsequent detection on photons comming from two waveguides. \nInputOutputWaveguideBasis for representing two waveguides (input and output) and the related generator functions zerophoton, onephoton, and twophoton. Also see inputemission,outputemission, inputabsorption and outputabsorption for creating operators acting on the basis. ","category":"page"},{"location":"","page":"CavityWaveguide.jl","title":"CavityWaveguide.jl","text":"DocTestSetup = quote\n    using CavityWaveguide\nend","category":"page"},{"location":"toturial_2time_continous/#Continous-two-photon-fock-states","page":"Continous Two Photon Fock States","title":"Continous two photon fock states","text":"","category":"section"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"So far we have considered only one excitation in the waveguide. We can extend the definition of a one-photon continous fock state to a two-photon state as[1]:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"Here, we here defined the two photon wavefunction xi^(2)(tt) = xi(t) xileft(t^primeright). The state is now defined over two times, which describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state xi^(2)(tt) = xi(t) xileft(t^primeright), and both probabilities are described by the (same) single photon wavefunction xi(t), but one could have entangled states across time. This means a non-seperable wavefunction xi^(2)(tt) neq xi_1(t)xi_2(t). For now we will consider a symmetric and seperable state.","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"The timebinning is in a similar fashion defined as:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac2sqrt2 sum_i=1^N sum_ki^N xileft(t_iright) xileft(t_kright)left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =sqrt2 sum_i=1^N sum_k  i^N xileft(t_iright) xileft(t_kright) mid 1_t_i 1_t_krangle + sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"The sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent having one photon at time bin k and then one photon at time bin j or one photon at time bin j and then one photon at time bin k). This is how the twophoton state is saved in the underlying arrays and we can define a twophoton basis as and corresponding twophoton state as:","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"bw = WaveguideBasis(2,times)\nξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ = twophoton(bw,ξ2,times,σ,t0)","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"Here, we defined the two photon equivalent of our single photon gaussian state. When we visualize it, we now need two times, and we make a contour plot. This is easily done viewing the twophoton state: ","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"using PyPlot\nviewed_state = TwoPhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,viewed_state,times)\nax.set_ylabel(\"time [1/γ]\")\nax.set_xlabel(\"time [1/γ]\") \nplt.tight_layout()","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"(Image: alt text)","category":"page"},{"location":"toturial_2time_continous/#Scattering-on-a-cavity","page":"Continous Two Photon Fock States","title":"Scattering on a cavity","text":"","category":"section"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"We now repeat the same setup as in Combining with QuantumOptics.jl but instead with a twophoton pulse scattering on the cavity. COMING UP!","category":"page"},{"location":"toturial_2time_continous/","page":"Continous Two Photon Fock States","title":"Continous Two Photon Fock States","text":"[1]: Ben Q. Baragiola, Robert L. Cook, Agata M. Branczyk, Joshua Combes (2012)","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CavityWaveguide]\nPrivate = false","category":"page"},{"location":"API/#CavityWaveguide.CavityWaveguideAbsorption","page":"API","title":"CavityWaveguide.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity creation and waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideEmission","page":"API","title":"CavityWaveguide.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.CavityWaveguideOperator","page":"API","title":"CavityWaveguide.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.Detector","page":"API","title":"CavityWaveguide.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.InputOutputTimestepView","page":"API","title":"CavityWaveguide.InputOutputTimestepView","text":"InputOutputTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in one photon input output state.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.InputOutputView","page":"API","title":"CavityWaveguide.InputOutputView","text":"InputOutputView{T} <: AbstractMatrix{T}\n\nStructure for viewing state with one photon in input and output waveguide. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.InputOutputWaveguideBasis","page":"API","title":"CavityWaveguide.InputOutputWaveguideBasis","text":"InputOutputWaveguideBasis(N,times)\n\nBasis for two waveguides containing in total N excitations. The two waveguides are refered to as input and output, but they are identical. Currently restricted to either N=1 or N=2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazySumKet","page":"API","title":"CavityWaveguide.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazyTensorBra","page":"API","title":"CavityWaveguide.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.LazyTensorKet","page":"API","title":"CavityWaveguide.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.OnePhotonView-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.OnePhotonView","text":"OnePhotonView(ψ::Ket)\nOnePhotonView(ψ::Ket,type)\nOnePhotonView(ψ::Ket,index)\nOnePhotonView(ψ::Ket,index,typw)\n\nReturn a view of the onephoton mode ξ(t) given a state defined on a WaveguideBasis or InputOutputWaveguideBasis. If the state is a InputOutputWaveguideBasis the type parameter can be used to choose between the input or output mode with type = :input or type = :output    If no index is provided the ground state is returned. Index should follow same form outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.TwoPhotonTimestepView","page":"API","title":"CavityWaveguide.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.TwoPhotonView","page":"API","title":"CavityWaveguide.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state as symmetric matrix (only upper triangluar part is stored in memory).\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideBasis","page":"API","title":"CavityWaveguide.WaveguideBasis","text":"WaveguideBasis(N, times)\n\nBasis for time binned Waveguide where N is the number of photons in the waveguide. Currently restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideCreate","page":"API","title":"CavityWaveguide.WaveguideCreate","text":"WaveguideCreate{N} <: WaveguideOperator\n\nOperator structure for dispatching creation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideDestroy","page":"API","title":"CavityWaveguide.WaveguideDestroy","text":"WaveguideDestroy{N} <: WaveguideOperator\n\nOperator structure for dispatching annihilation operation on Waveguide state. N is used to dispatch one or two photon routine. \n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.WaveguideOperator","page":"API","title":"CavityWaveguide.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#CavityWaveguide.absorption-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"CavityWaveguide.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"CavityWaveguide.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.emission-Union{Tuple{T}, Tuple{WaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"CavityWaveguide.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"CavityWaveguide.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = BW ⊗ BC where BW is a WaveguideBasis and BC some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = BC ⊗ BW with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"CavityWaveguide.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.get_waveguidetimeindex-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.get_waveguidetimeindex","text":"get_waveguidetimeindex(basis::WaveguideBasis)\nget_waveguidetimeindex(basis::Basis)\nget_waveguidetimeindex(basis::CompositeBasis)\n\nReturn timeindex of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputabsorption-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.inputabsorption","text":"inputabsorption(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\ninputabsorption(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and inputdestroy(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputcreate-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.inputcreate","text":"inputcreate(basis::WaveguideBasis{N}) where N\n\nCreation operator for input waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputdestroy-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.inputdestroy","text":"inputdestroy(basis::WaveguideBasis{N})\n\nAnnihilation operator for input waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.inputemission-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.inputemission","text":"inputemission(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\ninputemission(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and inputcreate(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.onephoton-Tuple{InputOutputWaveguideBasis, Any, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.onephoton","text":"onephoton(b::InputOutputWaveguideBasis,type,ξ::Function,times,args...,norm=True)\nonephoton(b::InputOutputWaveguideBasis,type,ξ;norm=true)\n\nCreate a onephoton wavepacket of the form W_io^dagger(xi) emptysetemptyset rangle = int_t_0^t_end dt  xi(t) w_io^dagger(t) emptysetemptyset rangle where the subscript i/o denotes the input or output waveguide and determined by the type parameter.\n\nInput\n\nb is the basis of the input output waveguides.    \ntype determines which waveguide the onephoton state is created in. Can be either :input or :outputput.\nξ can either be a function evaluated as ξ.(times,args...) or a vector of length: b.nsteps.\nIf norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.onephoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.onephoton","text":"onephoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\nonephoton(b::WaveguideBasis,ξvec;norm=true)\n\nCreate a onephoton wavepacket of the form W^dagger(xi) 0 = int_t_0^t_end dt  xi(t) w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ.(times,args...). ξvec is a vector of length: b.nsteps. If norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputabsorption-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.outputabsorption","text":"outputabsorption(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\noutputabsorption(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and outputdestroy(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputcreate-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.outputcreate","text":"Outputcreate(basis::WaveguideBasis{N}) where N\n\nCreation operator for output waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputdestroy-Union{Tuple{InputOutputWaveguideBasis{N}}, Tuple{N}} where N","page":"API","title":"CavityWaveguide.outputdestroy","text":"outputdestroy(basis::WaveguideBasis{N})\n\nAnnihilation operator for output waveguide in InputOutputWaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.outputemission-Union{Tuple{T}, Tuple{InputOutputWaveguideBasis{T}, QuantumInterface.FockBasis}} where T","page":"API","title":"CavityWaveguide.outputemission","text":"outputemission(b1::InputOutputWaveguideBasis{T},b2::FockBasis) where T\noutputemission(b1::FockBasis,b2::InputOutputWaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and outputcreate(b::InputOutputWaveguideBasis{T}) on InputOutputWaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"CavityWaveguide.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times)\nplot_twophoton!(ax,state::Ket,times)\n\nPlots the twophoton state in the given ax. If state is a Ket TwoPhotonView is called to extract twophotonstate.  Returns ax.contour object.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"CavityWaveguide.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.twophoton-Tuple{InputOutputWaveguideBasis, Any, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.twophoton","text":"twophoton(b::InputOutputWaveguideBasis,type,ξ::Function,times,args...,norm=True)\ntwophoton(b::InputOutputWaveguideBasis,type,ξ;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_io^dagger(t)w_io^dagger(t) emptysetemptyset rangle The subscript i/o denotes the input or output waveguide and is determined by the type parameter.\n\nInput\n\nb is the basis of the input output waveguides.    \ntype determines which waveguide the twophoton state is created in. Can be either :input or :outputput or :inputoutput for an entangled onephoton state in the input waveguide and onephoton state in the outputwaveguide.\nξ can either be a function evaluated as ξ.(times,args...) or a vector of length: b.nsteps.\nIf norm==true the state is normalized through normalize!.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.twophoton-Tuple{WaveguideBasis, Function, Any, Vararg{Any}}","page":"API","title":"CavityWaveguide.twophoton","text":"twophoton(b::WaveguideBasis,ξ::Function,times,args...,norm=True)\ntwophoton(b::WaveguideBasis,ξvec::Matrix;norm=true)\n\nCreate a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w^dagger(t)w^dagger(t) 0. Here t_0=0 and t_end is determined by WaveguideBasis. ξ is a function evaluated as ξ(t1,t2,args...). ξvec is a matrix of dimension: (b.nsteps,b.nsteps), where ξvec[i,j] = ξ(times[i],times[j]), where times is defined in WaveguideBasis.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"CavityWaveguide.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\ntimes=0:0.1:10\nbw = WaveguideBasis(2,times)\nbc1 = FockBasis(2)\nbc2 = FockBasis(2)\nψ_waveguide = onephoton(bw,x->1)\nψ_total = ψ_waveguide ⊗ fockstate(bc1,1) ⊗ fockstate(bc2,1)\nψ_view = view_waveguide(ψ_total)\nψ_view_index = view_waveguide(ψ_total,[:,1,1])\nψ_view==ψ_view_index\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"CavityWaveguide.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.   ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nOutput\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\n\nExample fout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"CavityWaveguide.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.zerophoton-Tuple{InputOutputWaveguideBasis}","page":"API","title":"CavityWaveguide.zerophoton","text":"zerophoton(bw::InputOutputWaveguideBasis)\n\nCreate a waveguide vacuum state emptysetemptyset rangle of the two waveguides.\n\n\n\n\n\n","category":"method"},{"location":"API/#CavityWaveguide.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"CavityWaveguide.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state |0⟩\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.dagger-Tuple{InputWaveguideCreate}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideDestroy)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.dagger-Tuple{WaveguideCreate}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}","page":"API","title":"QuantumInterface.tensor","text":"tensor(op1::AbstractOperator,op2::CavityWaveguideAbsorption)\ntensor(op1::CavityWaveguideAbsorption,op2::AbstractOperator)\ntensor(op1::AbstractOperator,op2::CavityWaveguideEmission)\ntensor(op1::CavityWaveguideEmission,op2::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.create-Tuple{WaveguideBasis{1}}","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.destroy-Tuple{WaveguideBasis{1}}","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{CavityWaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.identityoperator-Tuple{WaveguideOperator}","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.mul!","category":"page"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\nmul!(result::Bra{B1}, a::Bra{B2}, b::LazyTensor{B1,B2,F,I,T}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideOperator, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Bra{B1}, a::Bra{B2}, b::CavityWaveguideOperator, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator. Routine only works if [WaveguideBasis] is the first or last basis in Hilbertspace. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.create","category":"page"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{1})\ncreate(basis::WaveguideBasis{2})\n\nCreation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.destroy","category":"page"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{1})\ndestroy(basis::WaveguideBasis{2})\n\nAnnihilation operator for WaveguideBasis for either one or two photons. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.dagger","category":"page"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\ndagger(op::WaveguideCreate)\ndagger(op::WaveguideDestroy)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.tensor","category":"page"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(op1::AbstractOperator,op2::CavityWaveguideAbsorption)\ntensor(op1::CavityWaveguideAbsorption,op2::AbstractOperator)\ntensor(op1::AbstractOperator,op2::CavityWaveguideEmission)\ntensor(op1::CavityWaveguideEmission,op2::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"CavityWaveguide.identityoperator","category":"page"},{"location":"API/#QuantumOpticsBase.identityoperator","page":"API","title":"QuantumOpticsBase.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basisl). QUESTION: (does basisl or basis_r matter?)\n\n\n\n\n\n","category":"function"}]
}
